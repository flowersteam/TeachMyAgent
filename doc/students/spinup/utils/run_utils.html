<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>TeachMyAgent.students.spinup.utils.run_utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>TeachMyAgent.students.spinup.utils.run_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from TeachMyAgent.students.spinup.user_config import DEFAULT_DATA_DIR, FORCE_DATESTAMP, \
                               DEFAULT_SHORTHAND, WAIT_BEFORE_LAUNCH
from TeachMyAgent.students.spinup.utils.logx import colorize
from TeachMyAgent.students.spinup.utils.mpi_tools import mpi_fork, msg
from TeachMyAgent.students.spinup.utils.serialization_utils import convert_json
import base64
from copy import deepcopy
import cloudpickle
import json
import numpy as np
import os
import os.path as osp
import psutil
import string
import subprocess
from subprocess import CalledProcessError
import sys
from textwrap import dedent
import time
from tqdm import trange
import zlib

DIV_LINE_WIDTH = 80

def setup_logger_kwargs(exp_name, seed=None, data_dir=None, datestamp=False):
    &#34;&#34;&#34;
    Sets up the output_dir for a logger and returns a dict for logger kwargs.

    If no seed is given and datestamp is false, 

    ::

        output_dir = data_dir/exp_name

    If a seed is given and datestamp is false,

    ::

        output_dir = data_dir/exp_name/exp_name_s[seed]

    If datestamp is true, amend to

    ::

        output_dir = data_dir/YY-MM-DD_exp_name/YY-MM-DD_HH-MM-SS_exp_name_s[seed]

    You can force datestamp=True by setting ``FORCE_DATESTAMP=True`` in 
    ``students/user_config.py``.

    Args:

        exp_name (string): Name for experiment.

        seed (int): Seed for random number generators used by experiment.

        data_dir (string): Path to folder where results should be saved.
            Default is the ``DEFAULT_DATA_DIR`` in ``students/user_config.py``.

        datestamp (bool): Whether to include a date and timestamp in the
            name of the save directory.

    Returns:

        logger_kwargs, a dict containing output_dir and exp_name.
    &#34;&#34;&#34;

    # Datestamp forcing
    datestamp = datestamp or FORCE_DATESTAMP

    # Make base path
    ymd_time = time.strftime(&#34;%Y-%m-%d_&#34;) if datestamp else &#39;&#39;
    relpath = &#39;&#39;.join([ymd_time, exp_name])
    
    if seed is not None:
        # Make a seed-specific subfolder in the experiment directory.
        if datestamp:
            hms_time = time.strftime(&#34;%Y-%m-%d_%H-%M-%S&#34;)
            subfolder = &#39;&#39;.join([hms_time, &#39;-&#39;, exp_name, &#39;_s&#39;, str(seed)])
        else:
            subfolder = &#39;&#39;.join([exp_name, &#39;_s&#39;, str(seed)])
        relpath = osp.join(relpath, subfolder)

    data_dir = data_dir or DEFAULT_DATA_DIR
    logger_kwargs = dict(output_dir=osp.join(data_dir, relpath), 
                         exp_name=exp_name)
    return logger_kwargs


def call_experiment(exp_name, thunk, seed=0, num_cpu=1, data_dir=None, 
                    datestamp=False, **kwargs):
    &#34;&#34;&#34;
    Run a function (thunk) with hyperparameters (kwargs), plus configuration.

    This wraps a few pieces of functionality which are useful when you want
    to run many experiments in sequence, including logger configuration and
    splitting into multiple processes for MPI. 

    There&#39;s also a SpinningUp-specific convenience added into executing the
    thunk: if ``env_name`` is one of the kwargs passed to call_experiment, it&#39;s
    assumed that the thunk accepts an argument called ``env_fn``, and that
    the ``env_fn`` should make a gym environment with the given ``env_name``. 

    The way the experiment is actually executed is slightly complicated: the
    function is serialized to a string, and then ``run_entrypoint.py`` is
    executed in a subprocess call with the serialized string as an argument.
    ``run_entrypoint.py`` unserializes the function call and executes it.
    We choose to do it this way---instead of just calling the function 
    directly here---to avoid leaking state between successive experiments.

    Args:

        exp_name (string): Name for experiment.

        thunk (callable): A python function.

        seed (int): Seed for random number generators.

        num_cpu (int): Number of MPI processes to split into. Also accepts
            &#39;auto&#39;, which will set up as many procs as there are cpus on
            the machine.

        data_dir (string): Used in configuring the logger, to decide where
            to store experiment results. Note: if left as None, data_dir will
            default to ``DEFAULT_DATA_DIR`` from ``students/user_config.py``.

        **kwargs: All kwargs to pass to thunk.

    &#34;&#34;&#34;

    # Determine number of CPU cores to run on
    num_cpu = psutil.cpu_count(logical=False) if num_cpu==&#39;auto&#39; else num_cpu

    # Send random seed to thunk
    kwargs[&#39;seed&#39;] = seed

    # Be friendly and print out your kwargs, so we all know what&#39;s up
    print(colorize(&#39;Running experiment:\n&#39;, color=&#39;cyan&#39;, bold=True))
    print(exp_name + &#39;\n&#39;)
    print(colorize(&#39;with kwargs:\n&#39;, color=&#39;cyan&#39;, bold=True))
    kwargs_json = convert_json(kwargs)
    print(json.dumps(kwargs_json, separators=(&#39;,&#39;,&#39;:\t&#39;), indent=4, sort_keys=True))
    print(&#39;\n&#39;)

    # Set up logger output directory
    if &#39;logger_kwargs&#39; not in kwargs:
        kwargs[&#39;logger_kwargs&#39;] = setup_logger_kwargs(exp_name, seed, data_dir, datestamp)
    else:
        print(&#39;Note: Call experiment is not handling logger_kwargs.\n&#39;)

    def thunk_plus():
        # Make &#39;env_fn&#39; from &#39;env_name&#39;
        if &#39;env_name&#39; in kwargs:
            import gym
            env_name = kwargs[&#39;env_name&#39;]
            kwargs[&#39;env_fn&#39;] = lambda : gym.make(env_name)
            del kwargs[&#39;env_name&#39;]

        # Fork into multiple processes
        mpi_fork(num_cpu)

        # Run thunk
        thunk(**kwargs)

    # Prepare to launch a script to run the experiment
    pickled_thunk = cloudpickle.dumps(thunk_plus)
    encoded_thunk = base64.b64encode(zlib.compress(pickled_thunk)).decode(&#39;utf-8&#39;)

    entrypoint = osp.join(osp.abspath(osp.dirname(__file__)),&#39;run_entrypoint.py&#39;)
    cmd = [sys.executable if sys.executable else &#39;python&#39;, entrypoint, encoded_thunk]
    try:
        subprocess.check_call(cmd, env=os.environ)
    except CalledProcessError:
        err_msg = &#39;\n&#39;*3 + &#39;=&#39;*DIV_LINE_WIDTH + &#39;\n&#39; + dedent(&#34;&#34;&#34;

            There appears to have been an error in your experiment.

            Check the traceback above to see what actually went wrong. The 
            traceback below, included for completeness (but probably not useful
            for diagnosing the error), shows the stack leading up to the 
            experiment launch.

            &#34;&#34;&#34;) + &#39;=&#39;*DIV_LINE_WIDTH + &#39;\n&#39;*3
        print(err_msg)
        raise

    # Tell the user about where results are, and how to check them
    logger_kwargs = kwargs[&#39;logger_kwargs&#39;]

    plot_cmd = &#39;python -m students.run plot &#39;+logger_kwargs[&#39;output_dir&#39;]
    plot_cmd = colorize(plot_cmd, &#39;green&#39;)

    test_cmd = &#39;python -m students.run test_policy &#39;+logger_kwargs[&#39;output_dir&#39;]
    test_cmd = colorize(test_cmd, &#39;green&#39;)

    output_msg = &#39;\n&#39;*5 + &#39;=&#39;*DIV_LINE_WIDTH +&#39;\n&#39; + dedent(&#34;&#34;&#34;\
    End of experiment.


    Plot results from this run with:

    %s


    Watch the trained agent with:

    %s


    &#34;&#34;&#34;%(plot_cmd,test_cmd)) + &#39;=&#39;*DIV_LINE_WIDTH + &#39;\n&#39;*5

    print(output_msg)


def all_bools(vals):
    return all([isinstance(v,bool) for v in vals])

def valid_str(v):
    &#34;&#34;&#34; 
    Convert a value or values to a string which could go in a filepath.

    Partly based on `this gist`_.

    .. _`this gist`: https://gist.github.com/seanh/93666

    &#34;&#34;&#34;
    if hasattr(v, &#39;__name__&#39;):
        return valid_str(v.__name__)

    if isinstance(v, tuple) or isinstance(v, list):
        return &#39;-&#39;.join([valid_str(x) for x in v])

    # Valid characters are &#39;-&#39;, &#39;_&#39;, and alphanumeric. Replace invalid chars
    # with &#39;-&#39;. 
    str_v = str(v).lower()
    valid_chars = &#34;-_%s%s&#34; % (string.ascii_letters, string.digits)
    str_v = &#39;&#39;.join(c if c in valid_chars else &#39;-&#39; for c in str_v)
    return str_v


class ExperimentGrid:
    &#34;&#34;&#34;
    Tool for running many experiments given hyperparameter ranges.
    &#34;&#34;&#34;

    def __init__(self, name=&#39;&#39;):
        self.keys = []
        self.vals = []
        self.shs = []
        self.in_names = []
        self.name(name)

    def name(self, _name):
        assert isinstance(_name, str), &#34;Name has to be a string.&#34;
        self._name = _name

    def print(self):
        &#34;&#34;&#34;Print a helpful report about the experiment grid.&#34;&#34;&#34;
        print(&#39;=&#39;*DIV_LINE_WIDTH)

        # Prepare announcement at top of printing. If the ExperimentGrid has a
        # short name, write this as one line. If the name is long, break the
        # announcement over two lines.
        base_msg = &#39;ExperimentGrid %s runs over parameters:\n&#39;
        name_insert = &#39;[&#39;+self._name+&#39;]&#39;
        if len(base_msg%name_insert) &lt;= 80:
            msg = base_msg%name_insert
        else:
            msg = base_msg%(name_insert+&#39;\n&#39;)
        print(colorize(msg, color=&#39;green&#39;, bold=True))

        # List off parameters, shorthands, and possible values.
        for k, v, sh in zip(self.keys, self.vals, self.shs):
            color_k = colorize(k.ljust(40), color=&#39;cyan&#39;, bold=True)
            print(&#39;&#39;, color_k, &#39;[&#39;+sh+&#39;]&#39; if sh is not None else &#39;&#39;, &#39;\n&#39;)
            for i, val in enumerate(v):
                print(&#39;\t&#39; + str(convert_json(val)))
            print()

        # Count up the number of variants. The number counting seeds
        # is the total number of experiments that will run; the number not
        # counting seeds is the total number of otherwise-unique configs
        # being investigated.
        nvars_total = int(np.prod([len(v) for v in self.vals]))
        if &#39;seed&#39; in self.keys:
            num_seeds = len(self.vals[self.keys.index(&#39;seed&#39;)])
            nvars_seedless = int(nvars_total / num_seeds)
        else:
            nvars_seedless = nvars_total
        print(&#39; Variants, counting seeds: &#39;.ljust(40), nvars_total)
        print(&#39; Variants, not counting seeds: &#39;.ljust(40), nvars_seedless)
        print()
        print(&#39;=&#39;*DIV_LINE_WIDTH)


    def _default_shorthand(self, key):
        # Create a default shorthand for the key, built from the first 
        # three letters of each colon-separated part.
        # But if the first three letters contains something which isn&#39;t
        # alphanumeric, shear that off.
        valid_chars = &#34;%s%s&#34; % (string.ascii_letters, string.digits)
        def shear(x):
            return &#39;&#39;.join(z for z in x[:3] if z in valid_chars)
        sh = &#39;-&#39;.join([shear(x) for x in key.split(&#39;:&#39;)])
        return sh

    def add(self, key, vals, shorthand=None, in_name=False):
        &#34;&#34;&#34;
        Add a parameter (key) to the grid config, with potential values (vals).

        By default, if a shorthand isn&#39;t given, one is automatically generated
        from the key using the first three letters of each colon-separated
        term. To disable this behavior, change ``DEFAULT_SHORTHAND`` in the
        ``students/user_config.py`` file to ``False``.

        Args:
            key (string): Name of parameter.

            vals (value or list of values): Allowed values of parameter.

            shorthand (string): Optional, shortened name of parameter. For 
                example, maybe the parameter ``steps_per_epoch`` is shortened
                to ``steps``. 

            in_name (bool): When constructing variant names, force the
                inclusion of this parameter into the name.
        &#34;&#34;&#34;
        assert isinstance(key, str), &#34;Key must be a string.&#34;
        assert shorthand is None or isinstance(shorthand, str), \
            &#34;Shorthand must be a string.&#34;
        if not isinstance(vals, list):
            vals = [vals]
        if DEFAULT_SHORTHAND and shorthand is None:
            shorthand = self._default_shorthand(key)
        self.keys.append(key)
        self.vals.append(vals)
        self.shs.append(shorthand)
        self.in_names.append(in_name)

    def variant_name(self, variant):
        &#34;&#34;&#34;
        Given a variant (dict of valid param/value pairs), make an exp_name.

        A variant&#39;s name is constructed as the grid name (if you&#39;ve given it 
        one), plus param names (or shorthands if available) and values 
        separated by underscores.

        Note: if ``seed`` is a parameter, it is not included in the name.
        &#34;&#34;&#34;

        def get_val(v, k):
            # Utility method for getting the correct value out of a variant
            # given as a nested dict. Assumes that a parameter name, k, 
            # describes a path into the nested dict, such that k=&#39;a:b:c&#39;
            # corresponds to value=variant[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]. Uses recursion
            # to get this.
            if k in v:
                return v[k]
            else:
                splits = k.split(&#39;:&#39;)
                k0, k1 = splits[0], &#39;:&#39;.join(splits[1:])
                return get_val(v[k0], k1)

        # Start the name off with the name of the variant generator.
        var_name = self._name

        # Build the rest of the name by looping through all parameters,
        # and deciding which ones need to go in there.
        for k, v, sh, inn in zip(self.keys, self.vals, self.shs, self.in_names):

            # Include a parameter in a name if either 1) it can take multiple
            # values, or 2) the user specified that it must appear in the name.
            # Except, however, when the parameter is &#39;seed&#39;. Seed is handled
            # differently so that runs of the same experiment, with different 
            # seeds, will be grouped by experiment name.
            if (len(v)&gt;1 or inn) and not(k==&#39;seed&#39;):

                # Use the shorthand if available, otherwise the full name.
                param_name = sh if sh is not None else k
                param_name = valid_str(param_name)

                # Get variant value for parameter k
                variant_val = get_val(variant, k)

                # Append to name
                if all_bools(v): 
                    # If this is a param which only takes boolean values,
                    # only include in the name if it&#39;s True for this variant.
                    var_name += (&#39;_&#39; + param_name) if variant_val else &#39;&#39;
                else:
                    var_name += &#39;_&#39; + param_name + valid_str(variant_val)

        return var_name.lstrip(&#39;_&#39;)

    def _variants(self, keys, vals):
        &#34;&#34;&#34;
        Recursively builds list of valid variants.
        &#34;&#34;&#34;
        if len(keys)==1:
            pre_variants = [dict()]
        else:
            pre_variants = self._variants(keys[1:], vals[1:])

        variants = []
        for val in vals[0]:
            for pre_v in pre_variants:
                v = {}
                v[keys[0]] = val
                v.update(pre_v)
                variants.append(v)
        return variants

    def variants(self):
        &#34;&#34;&#34;
        Makes a list of dicts, where each dict is a valid config in the grid.

        There is special handling for variant parameters whose names take
        the form

            ``&#39;full:param:name&#39;``.

        The colons are taken to indicate that these parameters should
        have a nested dict structure. eg, if there are two params,

            ====================  ===
            Key                   Val
            ====================  ===
            ``&#39;base:param:a&#39;``    1
            ``&#39;base:param:b&#39;``    2
            ====================  ===

        the variant dict will have the structure

        .. parsed-literal::

            variant = {
                base: {
                    param : {
                        a : 1,
                        b : 2
                        }
                    }    
                }
        &#34;&#34;&#34;
        flat_variants = self._variants(self.keys, self.vals)

        def unflatten_var(var):
            &#34;&#34;&#34; 
            Build the full nested dict version of var, based on key names.
            &#34;&#34;&#34;
            new_var = dict()
            unflatten_set = set()

            for k,v in var.items():
                if &#39;:&#39; in k:
                    splits = k.split(&#39;:&#39;)
                    k0 = splits[0]
                    assert k0 not in new_var or isinstance(new_var[k0], dict), \
                        &#34;You can&#39;t assign multiple values to the same key.&#34;

                    if not(k0 in new_var):
                        new_var[k0] = dict()

                    sub_k = &#39;:&#39;.join(splits[1:])
                    new_var[k0][sub_k] = v
                    unflatten_set.add(k0)
                else:
                    assert not(k in new_var), \
                        &#34;You can&#39;t assign multiple values to the same key.&#34;
                    new_var[k] = v

            # Make sure to fill out the nested dicts.
            for k in unflatten_set:
                new_var[k] = unflatten_var(new_var[k])

            return new_var

        new_variants = [unflatten_var(var) for var in flat_variants]
        return new_variants

    def run(self, thunk, num_cpu=1, data_dir=None, datestamp=False):
        &#34;&#34;&#34;
        Run each variant in the grid with function &#39;thunk&#39;.

        Note: &#39;thunk&#39; must be either a callable function, or a string. If it is
        a string, it must be the name of a parameter whose values are all 
        callable functions.

        Uses ``call_experiment`` to actually launch each experiment, and gives
        each variant a name using ``self.variant_name()``. 

        Maintenance note: the args for ExperimentGrid.run should track closely
        to the args for call_experiment. However, ``seed`` is omitted because
        we presume the user may add it as a parameter in the grid.
        &#34;&#34;&#34;

        # Print info about self.
        self.print()

        # Make the list of all variants.
        variants = self.variants()

        # Print variant names for the user.
        var_names = set([self.variant_name(var) for var in variants])
        var_names = sorted(list(var_names))
        line = &#39;=&#39;*DIV_LINE_WIDTH
        preparing = colorize(&#39;Preparing to run the following experiments...&#39;, 
                             color=&#39;green&#39;, bold=True)
        joined_var_names = &#39;\n&#39;.join(var_names)
        announcement = f&#34;\n{preparing}\n\n{joined_var_names}\n\n{line}&#34;
        print(announcement)


        if WAIT_BEFORE_LAUNCH &gt; 0:
            delay_msg = colorize(dedent(&#34;&#34;&#34;
            Launch delayed to give you a few seconds to review your experiments.

            To customize or disable this behavior, change WAIT_BEFORE_LAUNCH in
            students/user_config.py.

            &#34;&#34;&#34;), color=&#39;cyan&#39;, bold=True)+line
            print(delay_msg)
            wait, steps = WAIT_BEFORE_LAUNCH, 100
            prog_bar = trange(steps, desc=&#39;Launching in...&#39;, 
                              leave=False, ncols=DIV_LINE_WIDTH, 
                              mininterval=0.25,
                              bar_format=&#39;{desc}: {bar}| {remaining} {elapsed}&#39;)
            for _ in prog_bar:
                time.sleep(wait/steps)

        # Run the variants.
        for var in variants:
            exp_name = self.variant_name(var)

            # Figure out what the thunk is.
            if isinstance(thunk, str):
                # Assume one of the variant parameters has the same
                # name as the string you passed for thunk, and that 
                # variant[thunk] is a valid callable function.
                thunk_ = var[thunk]
                del var[thunk]
            else:
                # Assume thunk is given as a function.
                thunk_ = thunk

            call_experiment(exp_name, thunk_, num_cpu=num_cpu, 
                            data_dir=data_dir, datestamp=datestamp, **var)


def test_eg():
    eg = ExperimentGrid()
    eg.add(&#39;test:a&#39;, [1,2,3], &#39;ta&#39;, True)
    eg.add(&#39;test:b&#39;, [1,2,3])
    eg.add(&#39;some&#39;, [4,5])
    eg.add(&#39;why&#39;, [True,False])
    eg.add(&#39;huh&#39;, 5)
    eg.add(&#39;no&#39;, 6, in_name=True)
    return eg.variants()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.all_bools"><code class="name flex">
<span>def <span class="ident">all_bools</span></span>(<span>vals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_bools(vals):
    return all([isinstance(v,bool) for v in vals])</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.call_experiment"><code class="name flex">
<span>def <span class="ident">call_experiment</span></span>(<span>exp_name, thunk, seed=0, num_cpu=1, data_dir=None, datestamp=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a function (thunk) with hyperparameters (kwargs), plus configuration.</p>
<p>This wraps a few pieces of functionality which are useful when you want
to run many experiments in sequence, including logger configuration and
splitting into multiple processes for MPI. </p>
<p>There's also a SpinningUp-specific convenience added into executing the
thunk: if <code>env_name</code> is one of the kwargs passed to call_experiment, it's
assumed that the thunk accepts an argument called <code>env_fn</code>, and that
the <code>env_fn</code> should make a gym environment with the given <code>env_name</code>. </p>
<p>The way the experiment is actually executed is slightly complicated: the
function is serialized to a string, and then <code>run_entrypoint.py</code> is
executed in a subprocess call with the serialized string as an argument.
<code>run_entrypoint.py</code> unserializes the function call and executes it.
We choose to do it this way&mdash;instead of just calling the function
directly here&mdash;to avoid leaking state between successive experiments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exp_name</code></strong> :&ensp;<code>string</code></dt>
<dd>Name for experiment.</dd>
<dt><strong><code>thunk</code></strong> :&ensp;<code>callable</code></dt>
<dd>A python function.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed for random number generators.</dd>
<dt><strong><code>num_cpu</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of MPI processes to split into. Also accepts
'auto', which will set up as many procs as there are cpus on
the machine.</dd>
<dt><strong><code>data_dir</code></strong> :&ensp;<code>string</code></dt>
<dd>Used in configuring the logger, to decide where
to store experiment results. Note: if left as None, data_dir will
default to <code>DEFAULT_DATA_DIR</code> from <code>students/user_config.py</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>All kwargs to pass to thunk.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_experiment(exp_name, thunk, seed=0, num_cpu=1, data_dir=None, 
                    datestamp=False, **kwargs):
    &#34;&#34;&#34;
    Run a function (thunk) with hyperparameters (kwargs), plus configuration.

    This wraps a few pieces of functionality which are useful when you want
    to run many experiments in sequence, including logger configuration and
    splitting into multiple processes for MPI. 

    There&#39;s also a SpinningUp-specific convenience added into executing the
    thunk: if ``env_name`` is one of the kwargs passed to call_experiment, it&#39;s
    assumed that the thunk accepts an argument called ``env_fn``, and that
    the ``env_fn`` should make a gym environment with the given ``env_name``. 

    The way the experiment is actually executed is slightly complicated: the
    function is serialized to a string, and then ``run_entrypoint.py`` is
    executed in a subprocess call with the serialized string as an argument.
    ``run_entrypoint.py`` unserializes the function call and executes it.
    We choose to do it this way---instead of just calling the function 
    directly here---to avoid leaking state between successive experiments.

    Args:

        exp_name (string): Name for experiment.

        thunk (callable): A python function.

        seed (int): Seed for random number generators.

        num_cpu (int): Number of MPI processes to split into. Also accepts
            &#39;auto&#39;, which will set up as many procs as there are cpus on
            the machine.

        data_dir (string): Used in configuring the logger, to decide where
            to store experiment results. Note: if left as None, data_dir will
            default to ``DEFAULT_DATA_DIR`` from ``students/user_config.py``.

        **kwargs: All kwargs to pass to thunk.

    &#34;&#34;&#34;

    # Determine number of CPU cores to run on
    num_cpu = psutil.cpu_count(logical=False) if num_cpu==&#39;auto&#39; else num_cpu

    # Send random seed to thunk
    kwargs[&#39;seed&#39;] = seed

    # Be friendly and print out your kwargs, so we all know what&#39;s up
    print(colorize(&#39;Running experiment:\n&#39;, color=&#39;cyan&#39;, bold=True))
    print(exp_name + &#39;\n&#39;)
    print(colorize(&#39;with kwargs:\n&#39;, color=&#39;cyan&#39;, bold=True))
    kwargs_json = convert_json(kwargs)
    print(json.dumps(kwargs_json, separators=(&#39;,&#39;,&#39;:\t&#39;), indent=4, sort_keys=True))
    print(&#39;\n&#39;)

    # Set up logger output directory
    if &#39;logger_kwargs&#39; not in kwargs:
        kwargs[&#39;logger_kwargs&#39;] = setup_logger_kwargs(exp_name, seed, data_dir, datestamp)
    else:
        print(&#39;Note: Call experiment is not handling logger_kwargs.\n&#39;)

    def thunk_plus():
        # Make &#39;env_fn&#39; from &#39;env_name&#39;
        if &#39;env_name&#39; in kwargs:
            import gym
            env_name = kwargs[&#39;env_name&#39;]
            kwargs[&#39;env_fn&#39;] = lambda : gym.make(env_name)
            del kwargs[&#39;env_name&#39;]

        # Fork into multiple processes
        mpi_fork(num_cpu)

        # Run thunk
        thunk(**kwargs)

    # Prepare to launch a script to run the experiment
    pickled_thunk = cloudpickle.dumps(thunk_plus)
    encoded_thunk = base64.b64encode(zlib.compress(pickled_thunk)).decode(&#39;utf-8&#39;)

    entrypoint = osp.join(osp.abspath(osp.dirname(__file__)),&#39;run_entrypoint.py&#39;)
    cmd = [sys.executable if sys.executable else &#39;python&#39;, entrypoint, encoded_thunk]
    try:
        subprocess.check_call(cmd, env=os.environ)
    except CalledProcessError:
        err_msg = &#39;\n&#39;*3 + &#39;=&#39;*DIV_LINE_WIDTH + &#39;\n&#39; + dedent(&#34;&#34;&#34;

            There appears to have been an error in your experiment.

            Check the traceback above to see what actually went wrong. The 
            traceback below, included for completeness (but probably not useful
            for diagnosing the error), shows the stack leading up to the 
            experiment launch.

            &#34;&#34;&#34;) + &#39;=&#39;*DIV_LINE_WIDTH + &#39;\n&#39;*3
        print(err_msg)
        raise

    # Tell the user about where results are, and how to check them
    logger_kwargs = kwargs[&#39;logger_kwargs&#39;]

    plot_cmd = &#39;python -m students.run plot &#39;+logger_kwargs[&#39;output_dir&#39;]
    plot_cmd = colorize(plot_cmd, &#39;green&#39;)

    test_cmd = &#39;python -m students.run test_policy &#39;+logger_kwargs[&#39;output_dir&#39;]
    test_cmd = colorize(test_cmd, &#39;green&#39;)

    output_msg = &#39;\n&#39;*5 + &#39;=&#39;*DIV_LINE_WIDTH +&#39;\n&#39; + dedent(&#34;&#34;&#34;\
    End of experiment.


    Plot results from this run with:

    %s


    Watch the trained agent with:

    %s


    &#34;&#34;&#34;%(plot_cmd,test_cmd)) + &#39;=&#39;*DIV_LINE_WIDTH + &#39;\n&#39;*5

    print(output_msg)</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.setup_logger_kwargs"><code class="name flex">
<span>def <span class="ident">setup_logger_kwargs</span></span>(<span>exp_name, seed=None, data_dir=None, datestamp=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up the output_dir for a logger and returns a dict for logger kwargs.</p>
<p>If no seed is given and datestamp is false, </p>
<p>::</p>
<pre><code>output_dir = data_dir/exp_name
</code></pre>
<p>If a seed is given and datestamp is false,</p>
<p>::</p>
<pre><code>output_dir = data_dir/exp_name/exp_name_s[seed]
</code></pre>
<p>If datestamp is true, amend to</p>
<p>::</p>
<pre><code>output_dir = data_dir/YY-MM-DD_exp_name/YY-MM-DD_HH-MM-SS_exp_name_s[seed]
</code></pre>
<p>You can force datestamp=True by setting <code>FORCE_DATESTAMP=True</code> in
<code>students/user_config.py</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exp_name</code></strong> :&ensp;<code>string</code></dt>
<dd>Name for experiment.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed for random number generators used by experiment.</dd>
<dt><strong><code>data_dir</code></strong> :&ensp;<code>string</code></dt>
<dd>Path to folder where results should be saved.
Default is the <code>DEFAULT_DATA_DIR</code> in <code>students/user_config.py</code>.</dd>
<dt><strong><code>datestamp</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include a date and timestamp in the
name of the save directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>logger_kwargs, a dict containing output_dir and exp_name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_logger_kwargs(exp_name, seed=None, data_dir=None, datestamp=False):
    &#34;&#34;&#34;
    Sets up the output_dir for a logger and returns a dict for logger kwargs.

    If no seed is given and datestamp is false, 

    ::

        output_dir = data_dir/exp_name

    If a seed is given and datestamp is false,

    ::

        output_dir = data_dir/exp_name/exp_name_s[seed]

    If datestamp is true, amend to

    ::

        output_dir = data_dir/YY-MM-DD_exp_name/YY-MM-DD_HH-MM-SS_exp_name_s[seed]

    You can force datestamp=True by setting ``FORCE_DATESTAMP=True`` in 
    ``students/user_config.py``.

    Args:

        exp_name (string): Name for experiment.

        seed (int): Seed for random number generators used by experiment.

        data_dir (string): Path to folder where results should be saved.
            Default is the ``DEFAULT_DATA_DIR`` in ``students/user_config.py``.

        datestamp (bool): Whether to include a date and timestamp in the
            name of the save directory.

    Returns:

        logger_kwargs, a dict containing output_dir and exp_name.
    &#34;&#34;&#34;

    # Datestamp forcing
    datestamp = datestamp or FORCE_DATESTAMP

    # Make base path
    ymd_time = time.strftime(&#34;%Y-%m-%d_&#34;) if datestamp else &#39;&#39;
    relpath = &#39;&#39;.join([ymd_time, exp_name])
    
    if seed is not None:
        # Make a seed-specific subfolder in the experiment directory.
        if datestamp:
            hms_time = time.strftime(&#34;%Y-%m-%d_%H-%M-%S&#34;)
            subfolder = &#39;&#39;.join([hms_time, &#39;-&#39;, exp_name, &#39;_s&#39;, str(seed)])
        else:
            subfolder = &#39;&#39;.join([exp_name, &#39;_s&#39;, str(seed)])
        relpath = osp.join(relpath, subfolder)

    data_dir = data_dir or DEFAULT_DATA_DIR
    logger_kwargs = dict(output_dir=osp.join(data_dir, relpath), 
                         exp_name=exp_name)
    return logger_kwargs</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.test_eg"><code class="name flex">
<span>def <span class="ident">test_eg</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_eg():
    eg = ExperimentGrid()
    eg.add(&#39;test:a&#39;, [1,2,3], &#39;ta&#39;, True)
    eg.add(&#39;test:b&#39;, [1,2,3])
    eg.add(&#39;some&#39;, [4,5])
    eg.add(&#39;why&#39;, [True,False])
    eg.add(&#39;huh&#39;, 5)
    eg.add(&#39;no&#39;, 6, in_name=True)
    return eg.variants()</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.valid_str"><code class="name flex">
<span>def <span class="ident">valid_str</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a value or values to a string which could go in a filepath.</p>
<p>Partly based on <code>this gist</code>_.</p>
<p>.. _<code>this gist</code>: <a href="https://gist.github.com/seanh/93666">https://gist.github.com/seanh/93666</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid_str(v):
    &#34;&#34;&#34; 
    Convert a value or values to a string which could go in a filepath.

    Partly based on `this gist`_.

    .. _`this gist`: https://gist.github.com/seanh/93666

    &#34;&#34;&#34;
    if hasattr(v, &#39;__name__&#39;):
        return valid_str(v.__name__)

    if isinstance(v, tuple) or isinstance(v, list):
        return &#39;-&#39;.join([valid_str(x) for x in v])

    # Valid characters are &#39;-&#39;, &#39;_&#39;, and alphanumeric. Replace invalid chars
    # with &#39;-&#39;. 
    str_v = str(v).lower()
    valid_chars = &#34;-_%s%s&#34; % (string.ascii_letters, string.digits)
    str_v = &#39;&#39;.join(c if c in valid_chars else &#39;-&#39; for c in str_v)
    return str_v</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid"><code class="flex name class">
<span>class <span class="ident">ExperimentGrid</span></span>
<span>(</span><span>name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Tool for running many experiments given hyperparameter ranges.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExperimentGrid:
    &#34;&#34;&#34;
    Tool for running many experiments given hyperparameter ranges.
    &#34;&#34;&#34;

    def __init__(self, name=&#39;&#39;):
        self.keys = []
        self.vals = []
        self.shs = []
        self.in_names = []
        self.name(name)

    def name(self, _name):
        assert isinstance(_name, str), &#34;Name has to be a string.&#34;
        self._name = _name

    def print(self):
        &#34;&#34;&#34;Print a helpful report about the experiment grid.&#34;&#34;&#34;
        print(&#39;=&#39;*DIV_LINE_WIDTH)

        # Prepare announcement at top of printing. If the ExperimentGrid has a
        # short name, write this as one line. If the name is long, break the
        # announcement over two lines.
        base_msg = &#39;ExperimentGrid %s runs over parameters:\n&#39;
        name_insert = &#39;[&#39;+self._name+&#39;]&#39;
        if len(base_msg%name_insert) &lt;= 80:
            msg = base_msg%name_insert
        else:
            msg = base_msg%(name_insert+&#39;\n&#39;)
        print(colorize(msg, color=&#39;green&#39;, bold=True))

        # List off parameters, shorthands, and possible values.
        for k, v, sh in zip(self.keys, self.vals, self.shs):
            color_k = colorize(k.ljust(40), color=&#39;cyan&#39;, bold=True)
            print(&#39;&#39;, color_k, &#39;[&#39;+sh+&#39;]&#39; if sh is not None else &#39;&#39;, &#39;\n&#39;)
            for i, val in enumerate(v):
                print(&#39;\t&#39; + str(convert_json(val)))
            print()

        # Count up the number of variants. The number counting seeds
        # is the total number of experiments that will run; the number not
        # counting seeds is the total number of otherwise-unique configs
        # being investigated.
        nvars_total = int(np.prod([len(v) for v in self.vals]))
        if &#39;seed&#39; in self.keys:
            num_seeds = len(self.vals[self.keys.index(&#39;seed&#39;)])
            nvars_seedless = int(nvars_total / num_seeds)
        else:
            nvars_seedless = nvars_total
        print(&#39; Variants, counting seeds: &#39;.ljust(40), nvars_total)
        print(&#39; Variants, not counting seeds: &#39;.ljust(40), nvars_seedless)
        print()
        print(&#39;=&#39;*DIV_LINE_WIDTH)


    def _default_shorthand(self, key):
        # Create a default shorthand for the key, built from the first 
        # three letters of each colon-separated part.
        # But if the first three letters contains something which isn&#39;t
        # alphanumeric, shear that off.
        valid_chars = &#34;%s%s&#34; % (string.ascii_letters, string.digits)
        def shear(x):
            return &#39;&#39;.join(z for z in x[:3] if z in valid_chars)
        sh = &#39;-&#39;.join([shear(x) for x in key.split(&#39;:&#39;)])
        return sh

    def add(self, key, vals, shorthand=None, in_name=False):
        &#34;&#34;&#34;
        Add a parameter (key) to the grid config, with potential values (vals).

        By default, if a shorthand isn&#39;t given, one is automatically generated
        from the key using the first three letters of each colon-separated
        term. To disable this behavior, change ``DEFAULT_SHORTHAND`` in the
        ``students/user_config.py`` file to ``False``.

        Args:
            key (string): Name of parameter.

            vals (value or list of values): Allowed values of parameter.

            shorthand (string): Optional, shortened name of parameter. For 
                example, maybe the parameter ``steps_per_epoch`` is shortened
                to ``steps``. 

            in_name (bool): When constructing variant names, force the
                inclusion of this parameter into the name.
        &#34;&#34;&#34;
        assert isinstance(key, str), &#34;Key must be a string.&#34;
        assert shorthand is None or isinstance(shorthand, str), \
            &#34;Shorthand must be a string.&#34;
        if not isinstance(vals, list):
            vals = [vals]
        if DEFAULT_SHORTHAND and shorthand is None:
            shorthand = self._default_shorthand(key)
        self.keys.append(key)
        self.vals.append(vals)
        self.shs.append(shorthand)
        self.in_names.append(in_name)

    def variant_name(self, variant):
        &#34;&#34;&#34;
        Given a variant (dict of valid param/value pairs), make an exp_name.

        A variant&#39;s name is constructed as the grid name (if you&#39;ve given it 
        one), plus param names (or shorthands if available) and values 
        separated by underscores.

        Note: if ``seed`` is a parameter, it is not included in the name.
        &#34;&#34;&#34;

        def get_val(v, k):
            # Utility method for getting the correct value out of a variant
            # given as a nested dict. Assumes that a parameter name, k, 
            # describes a path into the nested dict, such that k=&#39;a:b:c&#39;
            # corresponds to value=variant[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]. Uses recursion
            # to get this.
            if k in v:
                return v[k]
            else:
                splits = k.split(&#39;:&#39;)
                k0, k1 = splits[0], &#39;:&#39;.join(splits[1:])
                return get_val(v[k0], k1)

        # Start the name off with the name of the variant generator.
        var_name = self._name

        # Build the rest of the name by looping through all parameters,
        # and deciding which ones need to go in there.
        for k, v, sh, inn in zip(self.keys, self.vals, self.shs, self.in_names):

            # Include a parameter in a name if either 1) it can take multiple
            # values, or 2) the user specified that it must appear in the name.
            # Except, however, when the parameter is &#39;seed&#39;. Seed is handled
            # differently so that runs of the same experiment, with different 
            # seeds, will be grouped by experiment name.
            if (len(v)&gt;1 or inn) and not(k==&#39;seed&#39;):

                # Use the shorthand if available, otherwise the full name.
                param_name = sh if sh is not None else k
                param_name = valid_str(param_name)

                # Get variant value for parameter k
                variant_val = get_val(variant, k)

                # Append to name
                if all_bools(v): 
                    # If this is a param which only takes boolean values,
                    # only include in the name if it&#39;s True for this variant.
                    var_name += (&#39;_&#39; + param_name) if variant_val else &#39;&#39;
                else:
                    var_name += &#39;_&#39; + param_name + valid_str(variant_val)

        return var_name.lstrip(&#39;_&#39;)

    def _variants(self, keys, vals):
        &#34;&#34;&#34;
        Recursively builds list of valid variants.
        &#34;&#34;&#34;
        if len(keys)==1:
            pre_variants = [dict()]
        else:
            pre_variants = self._variants(keys[1:], vals[1:])

        variants = []
        for val in vals[0]:
            for pre_v in pre_variants:
                v = {}
                v[keys[0]] = val
                v.update(pre_v)
                variants.append(v)
        return variants

    def variants(self):
        &#34;&#34;&#34;
        Makes a list of dicts, where each dict is a valid config in the grid.

        There is special handling for variant parameters whose names take
        the form

            ``&#39;full:param:name&#39;``.

        The colons are taken to indicate that these parameters should
        have a nested dict structure. eg, if there are two params,

            ====================  ===
            Key                   Val
            ====================  ===
            ``&#39;base:param:a&#39;``    1
            ``&#39;base:param:b&#39;``    2
            ====================  ===

        the variant dict will have the structure

        .. parsed-literal::

            variant = {
                base: {
                    param : {
                        a : 1,
                        b : 2
                        }
                    }    
                }
        &#34;&#34;&#34;
        flat_variants = self._variants(self.keys, self.vals)

        def unflatten_var(var):
            &#34;&#34;&#34; 
            Build the full nested dict version of var, based on key names.
            &#34;&#34;&#34;
            new_var = dict()
            unflatten_set = set()

            for k,v in var.items():
                if &#39;:&#39; in k:
                    splits = k.split(&#39;:&#39;)
                    k0 = splits[0]
                    assert k0 not in new_var or isinstance(new_var[k0], dict), \
                        &#34;You can&#39;t assign multiple values to the same key.&#34;

                    if not(k0 in new_var):
                        new_var[k0] = dict()

                    sub_k = &#39;:&#39;.join(splits[1:])
                    new_var[k0][sub_k] = v
                    unflatten_set.add(k0)
                else:
                    assert not(k in new_var), \
                        &#34;You can&#39;t assign multiple values to the same key.&#34;
                    new_var[k] = v

            # Make sure to fill out the nested dicts.
            for k in unflatten_set:
                new_var[k] = unflatten_var(new_var[k])

            return new_var

        new_variants = [unflatten_var(var) for var in flat_variants]
        return new_variants

    def run(self, thunk, num_cpu=1, data_dir=None, datestamp=False):
        &#34;&#34;&#34;
        Run each variant in the grid with function &#39;thunk&#39;.

        Note: &#39;thunk&#39; must be either a callable function, or a string. If it is
        a string, it must be the name of a parameter whose values are all 
        callable functions.

        Uses ``call_experiment`` to actually launch each experiment, and gives
        each variant a name using ``self.variant_name()``. 

        Maintenance note: the args for ExperimentGrid.run should track closely
        to the args for call_experiment. However, ``seed`` is omitted because
        we presume the user may add it as a parameter in the grid.
        &#34;&#34;&#34;

        # Print info about self.
        self.print()

        # Make the list of all variants.
        variants = self.variants()

        # Print variant names for the user.
        var_names = set([self.variant_name(var) for var in variants])
        var_names = sorted(list(var_names))
        line = &#39;=&#39;*DIV_LINE_WIDTH
        preparing = colorize(&#39;Preparing to run the following experiments...&#39;, 
                             color=&#39;green&#39;, bold=True)
        joined_var_names = &#39;\n&#39;.join(var_names)
        announcement = f&#34;\n{preparing}\n\n{joined_var_names}\n\n{line}&#34;
        print(announcement)


        if WAIT_BEFORE_LAUNCH &gt; 0:
            delay_msg = colorize(dedent(&#34;&#34;&#34;
            Launch delayed to give you a few seconds to review your experiments.

            To customize or disable this behavior, change WAIT_BEFORE_LAUNCH in
            students/user_config.py.

            &#34;&#34;&#34;), color=&#39;cyan&#39;, bold=True)+line
            print(delay_msg)
            wait, steps = WAIT_BEFORE_LAUNCH, 100
            prog_bar = trange(steps, desc=&#39;Launching in...&#39;, 
                              leave=False, ncols=DIV_LINE_WIDTH, 
                              mininterval=0.25,
                              bar_format=&#39;{desc}: {bar}| {remaining} {elapsed}&#39;)
            for _ in prog_bar:
                time.sleep(wait/steps)

        # Run the variants.
        for var in variants:
            exp_name = self.variant_name(var)

            # Figure out what the thunk is.
            if isinstance(thunk, str):
                # Assume one of the variant parameters has the same
                # name as the string you passed for thunk, and that 
                # variant[thunk] is a valid callable function.
                thunk_ = var[thunk]
                del var[thunk]
            else:
                # Assume thunk is given as a function.
                thunk_ = thunk

            call_experiment(exp_name, thunk_, num_cpu=num_cpu, 
                            data_dir=data_dir, datestamp=datestamp, **var)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, key, vals, shorthand=None, in_name=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a parameter (key) to the grid config, with potential values (vals).</p>
<p>By default, if a shorthand isn't given, one is automatically generated
from the key using the first three letters of each colon-separated
term. To disable this behavior, change <code>DEFAULT_SHORTHAND</code> in the
<code>students/user_config.py</code> file to <code>False</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of parameter.</dd>
<dt><strong><code>vals</code></strong> :&ensp;<code>value</code> or <code>list</code> of <code>values</code></dt>
<dd>Allowed values of parameter.</dd>
<dt><strong><code>shorthand</code></strong> :&ensp;<code>string</code></dt>
<dd>Optional, shortened name of parameter. For
example, maybe the parameter <code>steps_per_epoch</code> is shortened
to <code>steps</code>. </dd>
<dt><strong><code>in_name</code></strong> :&ensp;<code>bool</code></dt>
<dd>When constructing variant names, force the
inclusion of this parameter into the name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, key, vals, shorthand=None, in_name=False):
    &#34;&#34;&#34;
    Add a parameter (key) to the grid config, with potential values (vals).

    By default, if a shorthand isn&#39;t given, one is automatically generated
    from the key using the first three letters of each colon-separated
    term. To disable this behavior, change ``DEFAULT_SHORTHAND`` in the
    ``students/user_config.py`` file to ``False``.

    Args:
        key (string): Name of parameter.

        vals (value or list of values): Allowed values of parameter.

        shorthand (string): Optional, shortened name of parameter. For 
            example, maybe the parameter ``steps_per_epoch`` is shortened
            to ``steps``. 

        in_name (bool): When constructing variant names, force the
            inclusion of this parameter into the name.
    &#34;&#34;&#34;
    assert isinstance(key, str), &#34;Key must be a string.&#34;
    assert shorthand is None or isinstance(shorthand, str), \
        &#34;Shorthand must be a string.&#34;
    if not isinstance(vals, list):
        vals = [vals]
    if DEFAULT_SHORTHAND and shorthand is None:
        shorthand = self._default_shorthand(key)
    self.keys.append(key)
    self.vals.append(vals)
    self.shs.append(shorthand)
    self.in_names.append(in_name)</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>self, _name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name(self, _name):
    assert isinstance(_name, str), &#34;Name has to be a string.&#34;
    self._name = _name</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a helpful report about the experiment grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self):
    &#34;&#34;&#34;Print a helpful report about the experiment grid.&#34;&#34;&#34;
    print(&#39;=&#39;*DIV_LINE_WIDTH)

    # Prepare announcement at top of printing. If the ExperimentGrid has a
    # short name, write this as one line. If the name is long, break the
    # announcement over two lines.
    base_msg = &#39;ExperimentGrid %s runs over parameters:\n&#39;
    name_insert = &#39;[&#39;+self._name+&#39;]&#39;
    if len(base_msg%name_insert) &lt;= 80:
        msg = base_msg%name_insert
    else:
        msg = base_msg%(name_insert+&#39;\n&#39;)
    print(colorize(msg, color=&#39;green&#39;, bold=True))

    # List off parameters, shorthands, and possible values.
    for k, v, sh in zip(self.keys, self.vals, self.shs):
        color_k = colorize(k.ljust(40), color=&#39;cyan&#39;, bold=True)
        print(&#39;&#39;, color_k, &#39;[&#39;+sh+&#39;]&#39; if sh is not None else &#39;&#39;, &#39;\n&#39;)
        for i, val in enumerate(v):
            print(&#39;\t&#39; + str(convert_json(val)))
        print()

    # Count up the number of variants. The number counting seeds
    # is the total number of experiments that will run; the number not
    # counting seeds is the total number of otherwise-unique configs
    # being investigated.
    nvars_total = int(np.prod([len(v) for v in self.vals]))
    if &#39;seed&#39; in self.keys:
        num_seeds = len(self.vals[self.keys.index(&#39;seed&#39;)])
        nvars_seedless = int(nvars_total / num_seeds)
    else:
        nvars_seedless = nvars_total
    print(&#39; Variants, counting seeds: &#39;.ljust(40), nvars_total)
    print(&#39; Variants, not counting seeds: &#39;.ljust(40), nvars_seedless)
    print()
    print(&#39;=&#39;*DIV_LINE_WIDTH)</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, thunk, num_cpu=1, data_dir=None, datestamp=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run each variant in the grid with function 'thunk'.</p>
<p>Note: 'thunk' must be either a callable function, or a string. If it is
a string, it must be the name of a parameter whose values are all
callable functions.</p>
<p>Uses <code><a title="TeachMyAgent.students.spinup.utils.run_utils.call_experiment" href="#TeachMyAgent.students.spinup.utils.run_utils.call_experiment">call_experiment()</a></code> to actually launch each experiment, and gives
each variant a name using <code>self.variant_name()</code>. </p>
<p>Maintenance note: the args for ExperimentGrid.run should track closely
to the args for call_experiment. However, <code>seed</code> is omitted because
we presume the user may add it as a parameter in the grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, thunk, num_cpu=1, data_dir=None, datestamp=False):
    &#34;&#34;&#34;
    Run each variant in the grid with function &#39;thunk&#39;.

    Note: &#39;thunk&#39; must be either a callable function, or a string. If it is
    a string, it must be the name of a parameter whose values are all 
    callable functions.

    Uses ``call_experiment`` to actually launch each experiment, and gives
    each variant a name using ``self.variant_name()``. 

    Maintenance note: the args for ExperimentGrid.run should track closely
    to the args for call_experiment. However, ``seed`` is omitted because
    we presume the user may add it as a parameter in the grid.
    &#34;&#34;&#34;

    # Print info about self.
    self.print()

    # Make the list of all variants.
    variants = self.variants()

    # Print variant names for the user.
    var_names = set([self.variant_name(var) for var in variants])
    var_names = sorted(list(var_names))
    line = &#39;=&#39;*DIV_LINE_WIDTH
    preparing = colorize(&#39;Preparing to run the following experiments...&#39;, 
                         color=&#39;green&#39;, bold=True)
    joined_var_names = &#39;\n&#39;.join(var_names)
    announcement = f&#34;\n{preparing}\n\n{joined_var_names}\n\n{line}&#34;
    print(announcement)


    if WAIT_BEFORE_LAUNCH &gt; 0:
        delay_msg = colorize(dedent(&#34;&#34;&#34;
        Launch delayed to give you a few seconds to review your experiments.

        To customize or disable this behavior, change WAIT_BEFORE_LAUNCH in
        students/user_config.py.

        &#34;&#34;&#34;), color=&#39;cyan&#39;, bold=True)+line
        print(delay_msg)
        wait, steps = WAIT_BEFORE_LAUNCH, 100
        prog_bar = trange(steps, desc=&#39;Launching in...&#39;, 
                          leave=False, ncols=DIV_LINE_WIDTH, 
                          mininterval=0.25,
                          bar_format=&#39;{desc}: {bar}| {remaining} {elapsed}&#39;)
        for _ in prog_bar:
            time.sleep(wait/steps)

    # Run the variants.
    for var in variants:
        exp_name = self.variant_name(var)

        # Figure out what the thunk is.
        if isinstance(thunk, str):
            # Assume one of the variant parameters has the same
            # name as the string you passed for thunk, and that 
            # variant[thunk] is a valid callable function.
            thunk_ = var[thunk]
            del var[thunk]
        else:
            # Assume thunk is given as a function.
            thunk_ = thunk

        call_experiment(exp_name, thunk_, num_cpu=num_cpu, 
                        data_dir=data_dir, datestamp=datestamp, **var)</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.variant_name"><code class="name flex">
<span>def <span class="ident">variant_name</span></span>(<span>self, variant)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a variant (dict of valid param/value pairs), make an exp_name.</p>
<p>A variant's name is constructed as the grid name (if you've given it
one), plus param names (or shorthands if available) and values
separated by underscores.</p>
<p>Note: if <code>seed</code> is a parameter, it is not included in the name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variant_name(self, variant):
    &#34;&#34;&#34;
    Given a variant (dict of valid param/value pairs), make an exp_name.

    A variant&#39;s name is constructed as the grid name (if you&#39;ve given it 
    one), plus param names (or shorthands if available) and values 
    separated by underscores.

    Note: if ``seed`` is a parameter, it is not included in the name.
    &#34;&#34;&#34;

    def get_val(v, k):
        # Utility method for getting the correct value out of a variant
        # given as a nested dict. Assumes that a parameter name, k, 
        # describes a path into the nested dict, such that k=&#39;a:b:c&#39;
        # corresponds to value=variant[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]. Uses recursion
        # to get this.
        if k in v:
            return v[k]
        else:
            splits = k.split(&#39;:&#39;)
            k0, k1 = splits[0], &#39;:&#39;.join(splits[1:])
            return get_val(v[k0], k1)

    # Start the name off with the name of the variant generator.
    var_name = self._name

    # Build the rest of the name by looping through all parameters,
    # and deciding which ones need to go in there.
    for k, v, sh, inn in zip(self.keys, self.vals, self.shs, self.in_names):

        # Include a parameter in a name if either 1) it can take multiple
        # values, or 2) the user specified that it must appear in the name.
        # Except, however, when the parameter is &#39;seed&#39;. Seed is handled
        # differently so that runs of the same experiment, with different 
        # seeds, will be grouped by experiment name.
        if (len(v)&gt;1 or inn) and not(k==&#39;seed&#39;):

            # Use the shorthand if available, otherwise the full name.
            param_name = sh if sh is not None else k
            param_name = valid_str(param_name)

            # Get variant value for parameter k
            variant_val = get_val(variant, k)

            # Append to name
            if all_bools(v): 
                # If this is a param which only takes boolean values,
                # only include in the name if it&#39;s True for this variant.
                var_name += (&#39;_&#39; + param_name) if variant_val else &#39;&#39;
            else:
                var_name += &#39;_&#39; + param_name + valid_str(variant_val)

    return var_name.lstrip(&#39;_&#39;)</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.variants"><code class="name flex">
<span>def <span class="ident">variants</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a list of dicts, where each dict is a valid config in the grid.</p>
<p>There is special handling for variant parameters whose names take
the form</p>
<pre><code>``'full:param:name'``.
</code></pre>
<p>The colons are taken to indicate that these parameters should
have a nested dict structure. eg, if there are two params,</p>
<pre><code>====================  ===
Key                   Val
====================  ===
``'base:param:a'``    1
``'base:param:b'``    2
====================  ===
</code></pre>
<p>the variant dict will have the structure</p>
<p>.. parsed-literal::</p>
<pre><code>variant = {
    base: {
        param : {
            a : 1,
            b : 2
            }
        }    
    }
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variants(self):
    &#34;&#34;&#34;
    Makes a list of dicts, where each dict is a valid config in the grid.

    There is special handling for variant parameters whose names take
    the form

        ``&#39;full:param:name&#39;``.

    The colons are taken to indicate that these parameters should
    have a nested dict structure. eg, if there are two params,

        ====================  ===
        Key                   Val
        ====================  ===
        ``&#39;base:param:a&#39;``    1
        ``&#39;base:param:b&#39;``    2
        ====================  ===

    the variant dict will have the structure

    .. parsed-literal::

        variant = {
            base: {
                param : {
                    a : 1,
                    b : 2
                    }
                }    
            }
    &#34;&#34;&#34;
    flat_variants = self._variants(self.keys, self.vals)

    def unflatten_var(var):
        &#34;&#34;&#34; 
        Build the full nested dict version of var, based on key names.
        &#34;&#34;&#34;
        new_var = dict()
        unflatten_set = set()

        for k,v in var.items():
            if &#39;:&#39; in k:
                splits = k.split(&#39;:&#39;)
                k0 = splits[0]
                assert k0 not in new_var or isinstance(new_var[k0], dict), \
                    &#34;You can&#39;t assign multiple values to the same key.&#34;

                if not(k0 in new_var):
                    new_var[k0] = dict()

                sub_k = &#39;:&#39;.join(splits[1:])
                new_var[k0][sub_k] = v
                unflatten_set.add(k0)
            else:
                assert not(k in new_var), \
                    &#34;You can&#39;t assign multiple values to the same key.&#34;
                new_var[k] = v

        # Make sure to fill out the nested dicts.
        for k in unflatten_set:
            new_var[k] = unflatten_var(new_var[k])

        return new_var

    new_variants = [unflatten_var(var) for var in flat_variants]
    return new_variants</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="http://developmentalsystems.org/TeachMyAgent/doc/">
<img src="https://github.com/flowersteam/TeachMyAgent/blob/gh-pages/images/home/head_image.png?raw=true" style="display: block; margin: 1em auto">
</a>
<a href="http://developmentalsystems.org/TeachMyAgent/doc/">Home</a> | <a href="http://developmentalsystems.org/TeachMyAgent/">Website</a>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="TeachMyAgent.students.spinup.utils" href="index.html">TeachMyAgent.students.spinup.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.all_bools" href="#TeachMyAgent.students.spinup.utils.run_utils.all_bools">all_bools</a></code></li>
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.call_experiment" href="#TeachMyAgent.students.spinup.utils.run_utils.call_experiment">call_experiment</a></code></li>
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.setup_logger_kwargs" href="#TeachMyAgent.students.spinup.utils.run_utils.setup_logger_kwargs">setup_logger_kwargs</a></code></li>
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.test_eg" href="#TeachMyAgent.students.spinup.utils.run_utils.test_eg">test_eg</a></code></li>
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.valid_str" href="#TeachMyAgent.students.spinup.utils.run_utils.valid_str">valid_str</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid" href="#TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid">ExperimentGrid</a></code></h4>
<ul class="two-column">
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.add" href="#TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.add">add</a></code></li>
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.name" href="#TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.name">name</a></code></li>
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.print" href="#TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.print">print</a></code></li>
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.run" href="#TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.run">run</a></code></li>
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.variant_name" href="#TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.variant_name">variant_name</a></code></li>
<li><code><a title="TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.variants" href="#TeachMyAgent.students.spinup.utils.run_utils.ExperimentGrid.variants">variants</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>