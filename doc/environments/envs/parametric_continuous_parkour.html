<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>TeachMyAgent.environments.envs.parametric_continuous_parkour API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>TeachMyAgent.environments.envs.parametric_continuous_parkour</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Parametric Parkour continuous environment
# Initially created by Cl√©ment Romac.

#region Imports

import math
import os

import Box2D
import gym
import numpy as np
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef)
from gym import spaces
from gym.utils import seeding, EzPickle

from TeachMyAgent.environments.envs.Box2D_dynamics.water_dynamics import WaterDynamics, WaterContactDetector
from TeachMyAgent.environments.envs.Box2D_dynamics.climbing_dynamics import ClimbingDynamics, ClimbingContactDetector
from TeachMyAgent.environments.envs.PCGAgents.CPPN.TanHSoftplusMixCPPN import TanHSoftplusMixCPPN
from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes, CustomUserData


#endregion

#region Utils
class ContactDetector(WaterContactDetector, ClimbingContactDetector):
    &#39;&#39;&#39;
        Custom contact detector.
    &#39;&#39;&#39;
    def __init__(self, env):
        super(ContactDetector, self).__init__()
        self.env = env
    def BeginContact(self, contact):
        &#39;&#39;&#39;
            Triggered when contact is detected.

            Checks userData of each of the two fixtures colliding.
            If contact with water is detected, uses WaterContactDetector.
            If contact with graspable area is detected, uses ClimbingContactDetector.
            Otherwise sets `userData.has_contact` to True on the body if `body.userData.check_contact == True`.
            If `userData.is_contact_critical == True`, `env.critical_contact` is set to True, stopping the episode.
        &#39;&#39;&#39;
        bodies = [contact.fixtureA.body, contact.fixtureB.body]
        if any([body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
            WaterContactDetector.BeginContact(self, contact)
        elif any([body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
            ClimbingContactDetector.BeginContact(self, contact)
        else:
            if contact.fixtureA.sensor or contact.fixtureB.sensor:
                return
            for idx, body in enumerate(bodies):
                if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                    body.userData.has_contact = True
                    other_body = bodies[(idx + 1) % 2]
                    # Authorize climbing bodies to touch climbing parts
                    if body.userData.is_contact_critical and \
                            not (other_body.userData.object_type == CustomUserDataObjectTypes.GRIP_TERRAIN and
                                         self.env.agent_body.body_type == BodyTypesEnum.CLIMBER):
                        self.env.critical_contact = True

    def EndContact(self, contact):
        &#39;&#39;&#39;
            Triggered when contact ends.

            If contact with water is detected, uses WaterContactDetector.
            If contact with graspable area is detected, uses ClimbingContactDetector.
            Otherwise sets `userData.has_contact` to False on the body if `body.userData.check_contact == True`.
        &#39;&#39;&#39;
        bodies = [contact.fixtureA.body, contact.fixtureB.body]
        if any([body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
            WaterContactDetector.EndContact(self, contact)
        elif any([body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
            ClimbingContactDetector.EndContact(self, contact)
        else:
            for body in [contact.fixtureA.body, contact.fixtureB.body]:
                if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                    body.userData.has_contact = False

    def Reset(self):
        WaterContactDetector.Reset(self)
        ClimbingContactDetector.Reset(self)


class LidarCallback(Box2D.b2.rayCastCallback):
    &#39;&#39;&#39;
        Callback function triggered when lidar detects an object.
    &#39;&#39;&#39;
    def __init__(self, agent_mask_filter):
        &#39;&#39;&#39;
            Args:
                agent_mask_filter: Mask filter used to avoid detecting collisions with the agent&#39;s body
        &#39;&#39;&#39;
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
        self.is_water_detected = False
        self.is_creeper_detected = False
    def ReportFixture(self, fixture, point, normal, fraction):
        &#39;&#39;&#39;
            Triggered when a body is detected by the lidar.

            Returns:
                 Distance to object detected.
        &#39;&#39;&#39;
        if (fixture.filterData.categoryBits &amp; self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        self.is_water_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.WATER else False
        self.is_creeper_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN else False
        return fraction
#endregion

#region Constants

FPS    = 50
SCALE  =  30.0   # affects how fast-paced the game is, forces should be adjusted as well
VIEWPORT_W = 600 # Careful, this affects training
VIEWPORT_H = 400 # Careful, this affects training

RENDERING_VIEWER_W = VIEWPORT_W # Only affects rendering, not the policy
RENDERING_VIEWER_H = VIEWPORT_H # Only affects rendering, not the policy

NB_LIDAR = 10 # Number of lidars used by the agent
LIDAR_RANGE   = 160/SCALE

INITIAL_RANDOM = 5

TERRAIN_STEP   = 14/SCALE
TERRAIN_LENGTH = 200     # in steps
TERRAIN_HEIGHT = VIEWPORT_H/SCALE/4
TERRAIN_END    = 5 # in steps
INITIAL_TERRAIN_STARTPAD = 20 # in steps
FRICTION = 2.5
WATER_DENSITY = 1.0
NB_FIRST_STEPS_HANG = 5

#endregion

class ParametricContinuousParkour(gym.Env, EzPickle):
    &#39;&#39;&#39;
        The Parkour: a procedurally generated Gym environment.
    &#39;&#39;&#39;
    metadata = {
        &#39;render.modes&#39;: [&#39;human&#39;, &#39;rgb_array&#39;],
        &#39;video.frames_per_second&#39; : FPS
    }

    def __init__(self, agent_body_type, CPPN_weights_path=None, input_CPPN_dim=3, terrain_cppn_scale=10,
                 ceiling_offset=200, ceiling_clip_offset=0, lidars_type=&#39;full&#39;, water_clip=20, movable_creepers=False,
                 **walker_args):
        &#39;&#39;&#39;
            Creates a Parkour environment with an embodiment.

            Args:
                agent_body_type (BodiesEnum): Embodiment
                CPPN_weights_path: Path to the CPPN&#39;s weights (leave to None for default)
                input_CPPN_dim: Dimensions of the vector controlling terrain&#39;s generation through the CPPN
                terrain_cppn_scale: How much values outputted by the CPNN must be scaled (default 10)
                ceiling_offset: Distance between ground and ceiling in the startpad
                ceiling_clip_offset: How close ceiling can get to the ground
                lidars_type: Type of lidars used by the agent (use &#39;up&#39; for climbers, &#39;down&#39; for walkers and &#39;full&#39; for swimmers)
                water_clip: Clips the push force applied under water (you should not need to change this)
                movable_creepers: Whether creepers should be one static rectangle or multiple dynamic rectangles linked by a joint
                walker_args: kwargs controlling the agent (e.g. number of body for a millipede)
        &#39;&#39;&#39;

        super(ParametricContinuousParkour, self).__init__()

        # Use &#39;down&#39; for walkers, &#39;up&#39; for climbers and &#39;full&#39; for swimmers.
        if lidars_type == &#34;down&#34;:
            self.lidar_angle = 1.5
            self.lidar_y_offset = 0
        elif lidars_type == &#34;up&#34;:
            self.lidar_angle = 2.3
            self.lidar_y_offset = 1.5
        elif lidars_type == &#34;full&#34;:
            self.lidar_angle = np.pi
            self.lidar_y_offset = 0

        # Seed env and init Box2D
        self.seed()
        self.viewer = None
        self.contact_listener = ContactDetector(self)
        self.world = Box2D.b2World(contactListener=self.contact_listener)
        self.movable_creepers = movable_creepers

        # Create agent
        body_type = BodiesEnum.get_body_type(agent_body_type)
        if body_type == BodyTypesEnum.SWIMMER or body_type == BodyTypesEnum.AMPHIBIAN:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, density=WATER_DENSITY, **walker_args)
        elif body_type == BodyTypesEnum.WALKER:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args,
                                                                reset_on_hull_critical_contact=False)
        else:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args)

        # Terrain and  dynamics
        self.terrain = []
        self.water_dynamics = WaterDynamics(self.world.gravity, max_push=water_clip)
        self.climbing_dynamics = ClimbingDynamics()
        self.prev_shaping = None
        self.episodic_reward = 0

        self.TERRAIN_STARTPAD = INITIAL_TERRAIN_STARTPAD if \
            self.agent_body.AGENT_WIDTH / TERRAIN_STEP + 5 &lt;= INITIAL_TERRAIN_STARTPAD else \
            self.agent_body.AGENT_WIDTH / TERRAIN_STEP + 5  # in steps
        self.create_terrain_fixtures()

        self.input_CPPN_dim = input_CPPN_dim
        if CPPN_weights_path is None:
            current_path = os.path.dirname(os.path.realpath(__file__))
            CPPN_weights_path = os.path.join(current_path, &#34;PCGAgents/CPPN/weights/same_ground_ceiling_cppn/&#34;)

        self.terrain_CPPN = TanHSoftplusMixCPPN(x_dim=TERRAIN_LENGTH,
                                                input_dim=input_CPPN_dim,
                                                weights_path=CPPN_weights_path,
                                                output_dim=2)  # ground + ceiling

        self.set_terrain_cppn_scale(terrain_cppn_scale, ceiling_offset, ceiling_clip_offset)

        # Set observation / action spaces
        self._generate_agent()  # To get state / action sizes
        agent_action_size = self.agent_body.get_action_size()
        self.action_space = spaces.Box(np.array([-1] * agent_action_size),
                                       np.array([1] * agent_action_size), dtype=np.float32)

        agent_state_size = self.agent_body.get_state_size()
        high = np.array([np.inf] * (agent_state_size +
                                    6 +  # head infos (including water) + is_dead
                                    NB_LIDAR*2))  # lidar info + if creeper for each lidar
        self.observation_space = spaces.Box(-high, high, dtype=np.float32)

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def set_terrain_cppn_scale(self, terrain_cppn_scale, ceiling_offset, ceiling_clip_offset):
        &#39;&#39;&#39;
            Scale the terrain generated by the CPPN to be more suited to our embodiments.
        &#39;&#39;&#39;
        assert terrain_cppn_scale &gt; 1
        self.TERRAIN_CPPN_SCALE = terrain_cppn_scale
        self.CEILING_LIMIT = 1000 / self.TERRAIN_CPPN_SCALE
        self.GROUND_LIMIT = -1000 / self.TERRAIN_CPPN_SCALE
        self.ceiling_offset = ceiling_offset / self.TERRAIN_CPPN_SCALE
        self.ceiling_clip_offset = ceiling_clip_offset / self.TERRAIN_CPPN_SCALE

    def set_environment(self, input_vector, water_level, creepers_width=None, creepers_height=None,
                        creepers_spacing=0.1, terrain_cppn_scale=10):
        &#39;&#39;&#39;
            Set the parameters controlling the PCG algorithm to generate a task.
            Call this method before `reset()`.

            Args:
                input_vector: Input vector controlling the CPPN
                water_level: Water level between 0.0 (no water at all) and 1.0 (full of water)
                creepers_width: Width of creepers
                creepers_height: Mean of creepers&#39; height (height is then sample using a normal distribution with a 0.1 std for each creeper)
                creepers_spacing: Spacing between creepers
                terrain_cppn_scale: How much values outputted by the CPNN must be scaled (default 10)
        &#39;&#39;&#39;
        self.CPPN_input_vector = input_vector
        self.water_level = water_level.item() if isinstance(water_level, np.float32) else water_level
        self.water_level = max(0.01, self.water_level)
        self.creepers_width = creepers_width if creepers_width is not None else creepers_width
        self.creepers_height = creepers_height if creepers_height is not None else creepers_height
        self.creepers_spacing = max(0.01, creepers_spacing)
        self.set_terrain_cppn_scale(terrain_cppn_scale,
                                    self.ceiling_offset*self.TERRAIN_CPPN_SCALE,
                                    self.ceiling_clip_offset*self.TERRAIN_CPPN_SCALE)

    def _destroy(self):
        # if not self.terrain: return
        for t in self.terrain:
            self.world.DestroyBody(t)
        self.terrain = []

        self.agent_body.destroy(self.world)

    def reset(self):
        self.world.contactListener = None
        self.contact_listener.Reset()
        self._destroy()
        self.world.contactListener = self.contact_listener
        self.critical_contact = False
        self.prev_shaping = None
        self.scroll = [0.0, 0.0]
        self.lidar_render = 0
        self.water_y = self.GROUND_LIMIT
        self.nb_steps_outside_water = 0
        self.nb_steps_under_water = 0

        self.generate_game()

        self.drawlist = self.terrain + self.agent_body.get_elements_to_render()

        self.lidar = [LidarCallback(self.agent_body.reference_head_object.fixtures[0].filterData.maskBits)
                      for _ in range(NB_LIDAR)]

        actions_to_play = np.array([0] * self.action_space.shape[0])
        # If embodiment is a climber, make it start hanging on the ceiling using a few steps to let the Box2D solver handle positions.
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            # Init climber
            y_diff = 0
            for i in range(len(self.agent_body.sensors)):
                actions_to_play[len(actions_to_play) - i - 1] = 1
                # Hang sensor
                sensor = self.agent_body.sensors[len(self.agent_body.sensors) - i - 1]
                if y_diff == 0:
                    y_diff = TERRAIN_HEIGHT + self.ceiling_offset - sensor.position[1]
                sensor.position = (sensor.position[0],
                                   TERRAIN_HEIGHT + self.ceiling_offset)

            for body_part in self.agent_body.body_parts:
                body_part.position = (body_part.position[0],
                                      body_part.position[1] + y_diff)

            for i in range(NB_FIRST_STEPS_HANG):
                self.step(actions_to_play)

        initial_state = self.step(actions_to_play)[0]
        self.nb_steps_outside_water = 0
        self.nb_steps_under_water = 0
        self.episodic_reward = 0
        return initial_state

    def step(self, action):
        # Check if agent&#39;s dead
        if hasattr(self.agent_body, &#34;nb_steps_can_survive_outside_water&#34;) and \
                        self.nb_steps_outside_water &gt; self.agent_body.nb_steps_can_survive_outside_water or \
                        hasattr(self.agent_body, &#34;nb_steps_can_survive_under_water&#34;) and \
                                self.nb_steps_under_water &gt; self.agent_body.nb_steps_can_survive_under_water:
            is_agent_dead = True
            action = np.array([0] * self.action_space.shape[0])
        else:
            is_agent_dead = False
        self.agent_body.activate_motors(action)

        # Prepare climbing dynamics according to the actions (i.e. sensor ready to grasp or sensor release destroying joint)
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            self.climbing_dynamics.before_step_climbing_dynamics(action, self.agent_body, self.world)

        self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)

        # Create joints between sensors ready to grasp if collision with graspable area was detected
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            self.climbing_dynamics.after_step_climbing_dynamics(self.world.contactListener, self.world)

        # Calculate water physics
        self.water_dynamics.calculate_forces(self.world.contactListener.fixture_pairs)

        head = self.agent_body.reference_head_object
        pos = head.position
        vel = head.linearVelocity

        for i in range(NB_LIDAR):
            self.lidar[i].fraction = 1.0
            self.lidar[i].p1 = pos
            self.lidar[i].p2 = (
                pos[0] + math.sin((self.lidar_angle * i / NB_LIDAR + self.lidar_y_offset)) * LIDAR_RANGE,
                pos[1] - math.cos((self.lidar_angle * i / NB_LIDAR) + self.lidar_y_offset) * LIDAR_RANGE)
            self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)

        is_under_water = pos.y &lt;= self.water_y
        if not is_agent_dead:
            if is_under_water:
                self.nb_steps_under_water += 1
                self.nb_steps_outside_water = 0
            else:
                self.nb_steps_outside_water += 1
                self.nb_steps_under_water = 0

        state = [
            head.angle,  # Normal angles up to 0.5 here, but sure more is possible.
            2.0 * head.angularVelocity / FPS,
            0.3 * vel.x * (VIEWPORT_W / SCALE) / FPS,  # Normalized to get -1..1 range
            0.3 * vel.y * (VIEWPORT_H / SCALE) / FPS,
            1.0 if is_under_water else 0.0,
            1.0 if is_agent_dead else 0.0
        ]

        # add leg-related state
        state.extend(self.agent_body.get_motors_state())

        # add sensor-related state
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            state.extend(self.agent_body.get_sensors_state())

        # add lidar-related state with distance and surface detected
        nb_of_water_detected = 0
        surface_dectected = []
        for lidar in self.lidar:
            state.append(lidar.fraction)
            if lidar.is_water_detected:
                surface_dectected.append(-1)
                nb_of_water_detected += 1
            elif lidar.is_creeper_detected:
                surface_dectected.append(1)
            else:
                surface_dectected.append(0)

        # state.append(nb_of_water_detected / NB_LIDAR)  # percentage of lidars that detect water
        state.extend(surface_dectected)

        self.scroll = [pos[0] - RENDERING_VIEWER_W / SCALE / 5,
                       pos[1] - RENDERING_VIEWER_H / SCALE / 5 - TERRAIN_HEIGHT + 1 / SCALE]  # 1 = grass

        shaping = 130 * pos[
            0] / SCALE  # moving forward is a way to receive reward (normalized to get 300 on completion)
        if not (
            hasattr(self.agent_body, &#34;remove_reward_on_head_angle&#34;) and self.agent_body.remove_reward_on_head_angle):
            shaping -= 5.0 * abs(
                state[0])  # keep head straight, other than that and falling, any behavior is unpunished

        reward = 0
        if self.prev_shaping is not None:
            reward = shaping - self.prev_shaping
        self.prev_shaping = shaping

        for a in action:
            reward -= self.agent_body.TORQUE_PENALTY * 80 * np.clip(np.abs(a), 0, 1)  # 80 =&gt; Original torque
            # normalized to about -50.0 using heuristic, more optimal agent should spend less

        # Ending conditions
        done = False
        if self.critical_contact or pos[0] &lt; 0:
            reward = -100
            done = True
        if pos[0] &gt; (TERRAIN_LENGTH + self.TERRAIN_STARTPAD - TERRAIN_END) * TERRAIN_STEP:
            done = True
        self.episodic_reward += reward

        return np.array(state), reward, done, {&#34;success&#34;: self.episodic_reward &gt; 230}

    def close(self):
        self.world.contactListener = None
        self.contact_listener.Reset()
        self._destroy()
        if self.viewer is not None:
            self.viewer.close()
            self.viewer = None

    # region Rendering
    # ------------------------------------------ RENDERING ------------------------------------------
    def color_agent_head(self, c1, c2):
        &#39;&#39;&#39;
            Color agent&#39;s head depending on its &#39;dying&#39; state.
        &#39;&#39;&#39;
        ratio = 0
        if hasattr(self.agent_body, &#34;nb_steps_can_survive_outside_water&#34;):
            ratio = self.nb_steps_outside_water / self.agent_body.nb_steps_can_survive_outside_water
        elif hasattr(self.agent_body, &#34;nb_steps_can_survive_under_water&#34;):
            ratio = self.nb_steps_under_water / self.agent_body.nb_steps_can_survive_under_water

        color1 = (c1[0] + ratio*(1.0 - c1[0]),
                  c1[1] + ratio*(0.0 - c1[1]),
                  c1[2] + ratio*(0.0 - c1[2]))
        color2 = c2
        return color1, color2

    def render(self, mode=&#39;human&#39;, draw_lidars=True):
        from gym.envs.classic_control import rendering
        if self.viewer is None:
            self.viewer = rendering.Viewer(RENDERING_VIEWER_W, RENDERING_VIEWER_H)
        self.viewer.set_bounds(self.scroll[0], RENDERING_VIEWER_W/SCALE + self.scroll[0], # x
                               self.scroll[1], RENDERING_VIEWER_H/SCALE + self.scroll[1]) # y

        self.viewer.draw_polygon( [
            (self.scroll[0], self.scroll[1]),
            (self.scroll[0]+RENDERING_VIEWER_W/SCALE, self.scroll[1]),
            (self.scroll[0]+RENDERING_VIEWER_W/SCALE, self.scroll[1]+RENDERING_VIEWER_H/SCALE),
            (self.scroll[0], self.scroll[1]+RENDERING_VIEWER_H/SCALE),
            ], color=(0.9, 0.9, 1.0) )

        for poly,x1,x2 in self.cloud_poly:
            if x2 &lt; self.scroll[0]/2: continue
            if x1 &gt; self.scroll[0]/2 + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon( [(p[0]+self.scroll[0]/2, p[1]) for p in poly], color=(1,1,1))

        for obj in self.drawlist:
            color1 = obj.color1
            color2 = obj.color2
            if obj.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and obj.userData.has_joint: # Color sensors when attached
                color1 = (1.0, 1.0, 0.0)
                color2 = (1.0, 1.0, 0.0)
            elif obj == self.agent_body.reference_head_object:
                color1, color2 = self.color_agent_head(color1, color2)

            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans*f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans*v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=color1)
                    path.append(path[0])
                    self.viewer.draw_polyline(path, color=color2, linewidth=2)

        for poly, color in self.terrain_poly:
            if poly[1][0] &lt; self.scroll[0]: continue
            if poly[0][0] &gt; self.scroll[0] + RENDERING_VIEWER_W / SCALE: continue
            self.viewer.draw_polygon(poly, color=color)

        # Draw lidars
        if draw_lidars:
            for i in range(len(self.lidar)):
                l = self.lidar[i]
                self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

        flagy1 = TERRAIN_HEIGHT
        flagy2 = flagy1 + 50/SCALE
        x = TERRAIN_STEP*3
        self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
        f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
        self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
        self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

        return self.viewer.render(return_rgb_array = mode==&#39;rgb_array&#39;)

    def _SET_RENDERING_VIEWPORT_SIZE(self, width, height=None, keep_ratio=True):
        &#39;&#39;&#39;
            Set rendering viewport&#39;s size (i.e. image size).

            Args:
                width: viewport&#39;s width
                height: viewport&#39;s height
                keep_ratio: Whether height must be automatically calculated to keep the same ratio as the environment&#39;s viewport size.
        &#39;&#39;&#39;
        global RENDERING_VIEWER_W, RENDERING_VIEWER_H
        RENDERING_VIEWER_W = width
        if keep_ratio or height is None:
            RENDERING_VIEWER_H = int(RENDERING_VIEWER_W / (VIEWPORT_W / VIEWPORT_H))
        else:
            RENDERING_VIEWER_H = height
    #endregion

    #region Fixtures Initialization
    # ------------------------------------------ FIXTURES INITIALIZATION ------------------------------------------

    def create_terrain_fixtures(self):
        &#39;&#39;&#39;
            Create fixtures used to generate terrain.
        &#39;&#39;&#39;
        self.fd_polygon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        self.fd_edge = fixtureDef(
            shape=edgeShape(vertices=
                            [(0, 0),
                             (1, 1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        self.fd_water = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            density=WATER_DENSITY,
            isSensor=True
        )

        self.fd_creeper = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            density=5.0,
            isSensor=True,
        )
    #endregion

    # region Game Generation
    # ------------------------------------------ GAME GENERATION ------------------------------------------

    def generate_game(self):
        &#39;&#39;&#39;
            Generate the task (i.e. terrain + embodiment).
        &#39;&#39;&#39;
        self._generate_terrain()
        self._generate_clouds()
        self._generate_agent()

    def clip_ceiling_values(self, row, clip_offset):
        if row[&#34;ceiling&#34;] &gt;= row[&#34;ground&#34;] + clip_offset:
            return row[&#34;ceiling&#34;]
        else:
            return row[&#34;ground&#34;] + clip_offset

    def _generate_terrain(self):
        y = self.terrain_CPPN.generate(self.CPPN_input_vector)
        y = y / self.TERRAIN_CPPN_SCALE
        ground_y = y[:, 0]
        ceiling_y = y[:, 1]

        # Align ground with startpad
        offset = TERRAIN_HEIGHT - ground_y[0]
        ground_y = np.add(ground_y, offset)

        # Align ceiling from startpad ceiling
        offset = TERRAIN_HEIGHT + self.ceiling_offset - ceiling_y[0]
        ceiling_y = np.add(ceiling_y, offset)

        self.terrain = []
        self.terrain_x = []
        self.terrain_ground_y = []
        self.terrain_ceiling_y = []
        terrain_creepers = []
        water_body = None
        x = 0
        max_x = TERRAIN_LENGTH * TERRAIN_STEP + self.TERRAIN_STARTPAD * TERRAIN_STEP

        # Generation of terrain
        i = 0
        while x &lt; max_x:
            self.terrain_x.append(x)
            if i &lt; self.TERRAIN_STARTPAD:
                self.terrain_ground_y.append(TERRAIN_HEIGHT)
                self.terrain_ceiling_y.append(TERRAIN_HEIGHT + self.ceiling_offset)
            else:
                self.terrain_ground_y.append(ground_y[i - self.TERRAIN_STARTPAD].item())

                # Clip ceiling
                if ceiling_y[i - self.TERRAIN_STARTPAD] &gt;= ground_y[i - self.TERRAIN_STARTPAD] + self.ceiling_clip_offset:
                    ceiling_val = ceiling_y[i - self.TERRAIN_STARTPAD]
                else:
                    ceiling_val = ground_y[i - self.TERRAIN_STARTPAD] + self.ceiling_clip_offset

                self.terrain_ceiling_y.append(ceiling_val.item())

            x += TERRAIN_STEP
            i += 1

        # Draw terrain
        space_from_precedent_creeper = self.creepers_spacing
        self.terrain_poly = []
        for i in range(len(self.terrain_x) - 1):
            # Ground
            poly = [
                (self.terrain_x[i], self.terrain_ground_y[i]),
                (self.terrain_x[i + 1], self.terrain_ground_y[i + 1])
            ]
            self.fd_edge.shape.vertices = poly
            t = self.world.CreateStaticBody(
                fixtures=self.fd_edge,
                userData=CustomUserData(&#34;grass&#34;, CustomUserDataObjectTypes.TERRAIN))
            color = (0.3, 1.0 if (i % 2) == 0 else 0.8, 0.3)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.4, 0.6, 0.3)
            poly += [(poly[1][0], self.GROUND_LIMIT), (poly[0][0], self.GROUND_LIMIT)]
            self.terrain_poly.append((poly, color))

            # Ceiling
            poly = [
                (self.terrain_x[i], self.terrain_ceiling_y[i]),
                (self.terrain_x[i + 1], self.terrain_ceiling_y[i + 1])
            ]
            self.fd_edge.shape.vertices = poly
            t = self.world.CreateStaticBody(
                fixtures=self.fd_edge,
                userData=CustomUserData(&#34;rock&#34;, CustomUserDataObjectTypes.GRIP_TERRAIN))
            color = (0, 0.25, 0.25)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.5, 0.5, 0.5)
            poly += [(poly[1][0], self.CEILING_LIMIT), (poly[0][0], self.CEILING_LIMIT)]
            self.terrain_poly.append((poly, color))

            # Creepers
            if self.creepers_width is not None and self.creepers_height is not None:
                if space_from_precedent_creeper &gt;= self.creepers_spacing:
                    creeper_height = max(0.2, self.np_random.normal(self.creepers_height, 0.1))
                    creeper_width = max(0.2, self.creepers_width)
                    creeper_step_size = np.floor(creeper_width / TERRAIN_STEP).astype(int)
                    creeper_step_size = max(1, creeper_step_size)
                    creeper_y_init_pos = max(self.terrain_ceiling_y[i],
                                             self.terrain_ceiling_y[min(i + creeper_step_size, len(self.terrain_x) - 1)])
                    if self.movable_creepers: # Break down creepers into multiple objects linked by joints
                        previous_creeper_part = t
                        for w in range(math.ceil(creeper_height)):
                            if w == creeper_height // 1:
                                h = max(0.2, creeper_height % 1)
                            else:
                                h = 1

                            poly = [
                                (self.terrain_x[i] + creeper_width, creeper_y_init_pos - (w * 1) - h),
                                (self.terrain_x[i] + creeper_width, creeper_y_init_pos - (w * 1)),
                                (self.terrain_x[i], creeper_y_init_pos - (w * 1)),
                                (self.terrain_x[i], creeper_y_init_pos - (w * 1) - h)
                            ]
                            self.fd_creeper.shape.vertices = poly
                            t = self.world.CreateDynamicBody(
                                fixtures=self.fd_creeper,
                                userData=CustomUserData(&#34;creeper&#34;, CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN))
                            c = (0.437, 0.504, 0.375)
                            t.color1 = c
                            t.color2 = tuple([_c+0.1 for _c  in c])
                            self.terrain.append(t)

                            rjd = revoluteJointDef(
                                bodyA=previous_creeper_part,
                                bodyB=t,
                                anchor=(self.terrain_x[i] + creeper_width / 2, creeper_y_init_pos - (w * 1)),
                                enableLimit=True,
                                lowerAngle=-0.4 * np.pi,
                                upperAngle=0.4 * np.pi,
                            )
                            self.world.CreateJoint(rjd)
                            previous_creeper_part = t
                    else:
                        poly = [
                            (self.terrain_x[i], creeper_y_init_pos),
                            (self.terrain_x[i] + creeper_width, creeper_y_init_pos),
                            (self.terrain_x[i] + creeper_width, creeper_y_init_pos - creeper_height),
                            (self.terrain_x[i], creeper_y_init_pos - creeper_height),
                        ]
                        self.fd_creeper.shape.vertices = poly
                        t = self.world.CreateStaticBody(
                            fixtures=self.fd_creeper,
                            userData=CustomUserData(&#34;creeper&#34;, CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN))
                        c = (0.437, 0.504, 0.375)
                        t.color1 = c
                        t.color2 = c
                        terrain_creepers.append(t)
                    space_from_precedent_creeper = 0
                else:
                    space_from_precedent_creeper += self.terrain_x[i] - self.terrain_x[i - 1]

        # Water
        # Fill water from GROUND_LIMIT to highest point of the current ceiling
        air_max_distance = max(self.terrain_ceiling_y) - self.GROUND_LIMIT
        water_y = self.GROUND_LIMIT + self.water_level * air_max_distance
        self.water_y = water_y

        water_poly = [
            (self.terrain_x[0], self.GROUND_LIMIT),
            (self.terrain_x[0], water_y),
            (self.terrain_x[len(self.terrain_x) - 1], water_y),
            (self.terrain_x[len(self.terrain_x) - 1], self.GROUND_LIMIT)
        ]
        self.fd_water.shape.vertices = water_poly
        t = self.world.CreateStaticBody(
            fixtures=self.fd_water,
            userData=CustomUserData(&#34;water&#34;, CustomUserDataObjectTypes.WATER))
        c = (0.465, 0.676, 0.898)
        t.color1 = c
        t.color2 = c
        water_body = t

        self.terrain.extend(terrain_creepers)
        if water_body is not None:
            self.terrain.append(water_body)
        self.terrain.reverse()


    def _generate_clouds(self):
        self.cloud_poly   = []
        for i in range(TERRAIN_LENGTH//20):
            x = self.np_random.uniform(0, TERRAIN_LENGTH)*TERRAIN_STEP
            y = VIEWPORT_H/SCALE*3/4
            poly = [
                (x+15*TERRAIN_STEP*math.sin(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP),
                 y+ 5*TERRAIN_STEP*math.cos(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP) )
                for a in range(5) ]
            x1 = min( [p[0] for p in poly] )
            x2 = max( [p[0] for p in poly] )
            self.cloud_poly.append( (poly,x1,x2) )

    def _generate_agent(self):
        init_x = TERRAIN_STEP*self.TERRAIN_STARTPAD/2
        init_y = TERRAIN_HEIGHT + self.agent_body.AGENT_CENTER_HEIGHT # set y position according to the agent

        self.agent_body.draw(
            self.world,
            init_x,
            init_y,
            self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM)
        )
    #endregion</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector"><code class="flex name class">
<span>class <span class="ident">ContactDetector</span></span>
<span>(</span><span>env)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom contact detector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContactDetector(WaterContactDetector, ClimbingContactDetector):
    &#39;&#39;&#39;
        Custom contact detector.
    &#39;&#39;&#39;
    def __init__(self, env):
        super(ContactDetector, self).__init__()
        self.env = env
    def BeginContact(self, contact):
        &#39;&#39;&#39;
            Triggered when contact is detected.

            Checks userData of each of the two fixtures colliding.
            If contact with water is detected, uses WaterContactDetector.
            If contact with graspable area is detected, uses ClimbingContactDetector.
            Otherwise sets `userData.has_contact` to True on the body if `body.userData.check_contact == True`.
            If `userData.is_contact_critical == True`, `env.critical_contact` is set to True, stopping the episode.
        &#39;&#39;&#39;
        bodies = [contact.fixtureA.body, contact.fixtureB.body]
        if any([body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
            WaterContactDetector.BeginContact(self, contact)
        elif any([body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
            ClimbingContactDetector.BeginContact(self, contact)
        else:
            if contact.fixtureA.sensor or contact.fixtureB.sensor:
                return
            for idx, body in enumerate(bodies):
                if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                    body.userData.has_contact = True
                    other_body = bodies[(idx + 1) % 2]
                    # Authorize climbing bodies to touch climbing parts
                    if body.userData.is_contact_critical and \
                            not (other_body.userData.object_type == CustomUserDataObjectTypes.GRIP_TERRAIN and
                                         self.env.agent_body.body_type == BodyTypesEnum.CLIMBER):
                        self.env.critical_contact = True

    def EndContact(self, contact):
        &#39;&#39;&#39;
            Triggered when contact ends.

            If contact with water is detected, uses WaterContactDetector.
            If contact with graspable area is detected, uses ClimbingContactDetector.
            Otherwise sets `userData.has_contact` to False on the body if `body.userData.check_contact == True`.
        &#39;&#39;&#39;
        bodies = [contact.fixtureA.body, contact.fixtureB.body]
        if any([body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
            WaterContactDetector.EndContact(self, contact)
        elif any([body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
            ClimbingContactDetector.EndContact(self, contact)
        else:
            for body in [contact.fixtureA.body, contact.fixtureB.body]:
                if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                    body.userData.has_contact = False

    def Reset(self):
        WaterContactDetector.Reset(self)
        ClimbingContactDetector.Reset(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="TeachMyAgent.environments.envs.Box2D_dynamics.water_dynamics.WaterContactDetector" href="Box2D_dynamics/water_dynamics.html#TeachMyAgent.environments.envs.Box2D_dynamics.water_dynamics.WaterContactDetector">WaterContactDetector</a></li>
<li><a title="TeachMyAgent.environments.envs.Box2D_dynamics.climbing_dynamics.ClimbingContactDetector" href="Box2D_dynamics/climbing_dynamics.html#TeachMyAgent.environments.envs.Box2D_dynamics.climbing_dynamics.ClimbingContactDetector">ClimbingContactDetector</a></li>
<li>Box2D.Box2D.b2ContactListener</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector.BeginContact"><code class="name flex">
<span>def <span class="ident">BeginContact</span></span>(<span>self, contact)</span>
</code></dt>
<dd>
<div class="desc"><p>Triggered when contact is detected.</p>
<p>Checks userData of each of the two fixtures colliding.
If contact with water is detected, uses WaterContactDetector.
If contact with graspable area is detected, uses ClimbingContactDetector.
Otherwise sets <code>userData.has_contact</code> to True on the body if <code>body.userData.check_contact == True</code>.
If <code>userData.is_contact_critical == True</code>, <code>env.critical_contact</code> is set to True, stopping the episode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BeginContact(self, contact):
    &#39;&#39;&#39;
        Triggered when contact is detected.

        Checks userData of each of the two fixtures colliding.
        If contact with water is detected, uses WaterContactDetector.
        If contact with graspable area is detected, uses ClimbingContactDetector.
        Otherwise sets `userData.has_contact` to True on the body if `body.userData.check_contact == True`.
        If `userData.is_contact_critical == True`, `env.critical_contact` is set to True, stopping the episode.
    &#39;&#39;&#39;
    bodies = [contact.fixtureA.body, contact.fixtureB.body]
    if any([body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
        WaterContactDetector.BeginContact(self, contact)
    elif any([body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
        ClimbingContactDetector.BeginContact(self, contact)
    else:
        if contact.fixtureA.sensor or contact.fixtureB.sensor:
            return
        for idx, body in enumerate(bodies):
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = True
                other_body = bodies[(idx + 1) % 2]
                # Authorize climbing bodies to touch climbing parts
                if body.userData.is_contact_critical and \
                        not (other_body.userData.object_type == CustomUserDataObjectTypes.GRIP_TERRAIN and
                                     self.env.agent_body.body_type == BodyTypesEnum.CLIMBER):
                    self.env.critical_contact = True</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector.EndContact"><code class="name flex">
<span>def <span class="ident">EndContact</span></span>(<span>self, contact)</span>
</code></dt>
<dd>
<div class="desc"><p>Triggered when contact ends.</p>
<p>If contact with water is detected, uses WaterContactDetector.
If contact with graspable area is detected, uses ClimbingContactDetector.
Otherwise sets <code>userData.has_contact</code> to False on the body if <code>body.userData.check_contact == True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndContact(self, contact):
    &#39;&#39;&#39;
        Triggered when contact ends.

        If contact with water is detected, uses WaterContactDetector.
        If contact with graspable area is detected, uses ClimbingContactDetector.
        Otherwise sets `userData.has_contact` to False on the body if `body.userData.check_contact == True`.
    &#39;&#39;&#39;
    bodies = [contact.fixtureA.body, contact.fixtureB.body]
    if any([body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
        WaterContactDetector.EndContact(self, contact)
    elif any([body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
        ClimbingContactDetector.EndContact(self, contact)
    else:
        for body in [contact.fixtureA.body, contact.fixtureB.body]:
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = False</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector.Reset"><code class="name flex">
<span>def <span class="ident">Reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Reset(self):
    WaterContactDetector.Reset(self)
    ClimbingContactDetector.Reset(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.LidarCallback"><code class="flex name class">
<span>class <span class="ident">LidarCallback</span></span>
<span>(</span><span>agent_mask_filter)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback function triggered when lidar detects an object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>agent_mask_filter</code></strong></dt>
<dd>Mask filter used to avoid detecting collisions with the agent's body</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LidarCallback(Box2D.b2.rayCastCallback):
    &#39;&#39;&#39;
        Callback function triggered when lidar detects an object.
    &#39;&#39;&#39;
    def __init__(self, agent_mask_filter):
        &#39;&#39;&#39;
            Args:
                agent_mask_filter: Mask filter used to avoid detecting collisions with the agent&#39;s body
        &#39;&#39;&#39;
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
        self.is_water_detected = False
        self.is_creeper_detected = False
    def ReportFixture(self, fixture, point, normal, fraction):
        &#39;&#39;&#39;
            Triggered when a body is detected by the lidar.

            Returns:
                 Distance to object detected.
        &#39;&#39;&#39;
        if (fixture.filterData.categoryBits &amp; self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        self.is_water_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.WATER else False
        self.is_creeper_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN else False
        return fraction</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>Box2D.Box2D.b2RayCastCallback</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.LidarCallback.ReportFixture"><code class="name flex">
<span>def <span class="ident">ReportFixture</span></span>(<span>self, fixture, point, normal, fraction)</span>
</code></dt>
<dd>
<div class="desc"><p>Triggered when a body is detected by the lidar.</p>
<h2 id="returns">Returns</h2>
<p>Distance to object detected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReportFixture(self, fixture, point, normal, fraction):
    &#39;&#39;&#39;
        Triggered when a body is detected by the lidar.

        Returns:
             Distance to object detected.
    &#39;&#39;&#39;
    if (fixture.filterData.categoryBits &amp; self.agent_mask_filter) == 0:
        return -1
    self.p2 = point
    self.fraction = fraction
    self.is_water_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.WATER else False
    self.is_creeper_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN else False
    return fraction</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour"><code class="flex name class">
<span>class <span class="ident">ParametricContinuousParkour</span></span>
<span>(</span><span>agent_body_type, CPPN_weights_path=None, input_CPPN_dim=3, terrain_cppn_scale=10, ceiling_offset=200, ceiling_clip_offset=0, lidars_type='full', water_clip=20, movable_creepers=False, **walker_args)</span>
</code></dt>
<dd>
<div class="desc"><p>The Parkour: a procedurally generated Gym environment.</p>
<p>Creates a Parkour environment with an embodiment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>agent_body_type</code></strong> :&ensp;<code>BodiesEnum</code></dt>
<dd>Embodiment</dd>
<dt><strong><code>CPPN_weights_path</code></strong></dt>
<dd>Path to the CPPN's weights (leave to None for default)</dd>
<dt><strong><code>input_CPPN_dim</code></strong></dt>
<dd>Dimensions of the vector controlling terrain's generation through the CPPN</dd>
<dt><strong><code>terrain_cppn_scale</code></strong></dt>
<dd>How much values outputted by the CPNN must be scaled (default 10)</dd>
<dt><strong><code>ceiling_offset</code></strong></dt>
<dd>Distance between ground and ceiling in the startpad</dd>
<dt><strong><code>ceiling_clip_offset</code></strong></dt>
<dd>How close ceiling can get to the ground</dd>
<dt><strong><code>lidars_type</code></strong></dt>
<dd>Type of lidars used by the agent (use 'up' for climbers, 'down' for walkers and 'full' for swimmers)</dd>
<dt><strong><code>water_clip</code></strong></dt>
<dd>Clips the push force applied under water (you should not need to change this)</dd>
<dt><strong><code>movable_creepers</code></strong></dt>
<dd>Whether creepers should be one static rectangle or multiple dynamic rectangles linked by a joint</dd>
<dt><strong><code>walker_args</code></strong></dt>
<dd>kwargs controlling the agent (e.g. number of body for a millipede)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParametricContinuousParkour(gym.Env, EzPickle):
    &#39;&#39;&#39;
        The Parkour: a procedurally generated Gym environment.
    &#39;&#39;&#39;
    metadata = {
        &#39;render.modes&#39;: [&#39;human&#39;, &#39;rgb_array&#39;],
        &#39;video.frames_per_second&#39; : FPS
    }

    def __init__(self, agent_body_type, CPPN_weights_path=None, input_CPPN_dim=3, terrain_cppn_scale=10,
                 ceiling_offset=200, ceiling_clip_offset=0, lidars_type=&#39;full&#39;, water_clip=20, movable_creepers=False,
                 **walker_args):
        &#39;&#39;&#39;
            Creates a Parkour environment with an embodiment.

            Args:
                agent_body_type (BodiesEnum): Embodiment
                CPPN_weights_path: Path to the CPPN&#39;s weights (leave to None for default)
                input_CPPN_dim: Dimensions of the vector controlling terrain&#39;s generation through the CPPN
                terrain_cppn_scale: How much values outputted by the CPNN must be scaled (default 10)
                ceiling_offset: Distance between ground and ceiling in the startpad
                ceiling_clip_offset: How close ceiling can get to the ground
                lidars_type: Type of lidars used by the agent (use &#39;up&#39; for climbers, &#39;down&#39; for walkers and &#39;full&#39; for swimmers)
                water_clip: Clips the push force applied under water (you should not need to change this)
                movable_creepers: Whether creepers should be one static rectangle or multiple dynamic rectangles linked by a joint
                walker_args: kwargs controlling the agent (e.g. number of body for a millipede)
        &#39;&#39;&#39;

        super(ParametricContinuousParkour, self).__init__()

        # Use &#39;down&#39; for walkers, &#39;up&#39; for climbers and &#39;full&#39; for swimmers.
        if lidars_type == &#34;down&#34;:
            self.lidar_angle = 1.5
            self.lidar_y_offset = 0
        elif lidars_type == &#34;up&#34;:
            self.lidar_angle = 2.3
            self.lidar_y_offset = 1.5
        elif lidars_type == &#34;full&#34;:
            self.lidar_angle = np.pi
            self.lidar_y_offset = 0

        # Seed env and init Box2D
        self.seed()
        self.viewer = None
        self.contact_listener = ContactDetector(self)
        self.world = Box2D.b2World(contactListener=self.contact_listener)
        self.movable_creepers = movable_creepers

        # Create agent
        body_type = BodiesEnum.get_body_type(agent_body_type)
        if body_type == BodyTypesEnum.SWIMMER or body_type == BodyTypesEnum.AMPHIBIAN:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, density=WATER_DENSITY, **walker_args)
        elif body_type == BodyTypesEnum.WALKER:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args,
                                                                reset_on_hull_critical_contact=False)
        else:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args)

        # Terrain and  dynamics
        self.terrain = []
        self.water_dynamics = WaterDynamics(self.world.gravity, max_push=water_clip)
        self.climbing_dynamics = ClimbingDynamics()
        self.prev_shaping = None
        self.episodic_reward = 0

        self.TERRAIN_STARTPAD = INITIAL_TERRAIN_STARTPAD if \
            self.agent_body.AGENT_WIDTH / TERRAIN_STEP + 5 &lt;= INITIAL_TERRAIN_STARTPAD else \
            self.agent_body.AGENT_WIDTH / TERRAIN_STEP + 5  # in steps
        self.create_terrain_fixtures()

        self.input_CPPN_dim = input_CPPN_dim
        if CPPN_weights_path is None:
            current_path = os.path.dirname(os.path.realpath(__file__))
            CPPN_weights_path = os.path.join(current_path, &#34;PCGAgents/CPPN/weights/same_ground_ceiling_cppn/&#34;)

        self.terrain_CPPN = TanHSoftplusMixCPPN(x_dim=TERRAIN_LENGTH,
                                                input_dim=input_CPPN_dim,
                                                weights_path=CPPN_weights_path,
                                                output_dim=2)  # ground + ceiling

        self.set_terrain_cppn_scale(terrain_cppn_scale, ceiling_offset, ceiling_clip_offset)

        # Set observation / action spaces
        self._generate_agent()  # To get state / action sizes
        agent_action_size = self.agent_body.get_action_size()
        self.action_space = spaces.Box(np.array([-1] * agent_action_size),
                                       np.array([1] * agent_action_size), dtype=np.float32)

        agent_state_size = self.agent_body.get_state_size()
        high = np.array([np.inf] * (agent_state_size +
                                    6 +  # head infos (including water) + is_dead
                                    NB_LIDAR*2))  # lidar info + if creeper for each lidar
        self.observation_space = spaces.Box(-high, high, dtype=np.float32)

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def set_terrain_cppn_scale(self, terrain_cppn_scale, ceiling_offset, ceiling_clip_offset):
        &#39;&#39;&#39;
            Scale the terrain generated by the CPPN to be more suited to our embodiments.
        &#39;&#39;&#39;
        assert terrain_cppn_scale &gt; 1
        self.TERRAIN_CPPN_SCALE = terrain_cppn_scale
        self.CEILING_LIMIT = 1000 / self.TERRAIN_CPPN_SCALE
        self.GROUND_LIMIT = -1000 / self.TERRAIN_CPPN_SCALE
        self.ceiling_offset = ceiling_offset / self.TERRAIN_CPPN_SCALE
        self.ceiling_clip_offset = ceiling_clip_offset / self.TERRAIN_CPPN_SCALE

    def set_environment(self, input_vector, water_level, creepers_width=None, creepers_height=None,
                        creepers_spacing=0.1, terrain_cppn_scale=10):
        &#39;&#39;&#39;
            Set the parameters controlling the PCG algorithm to generate a task.
            Call this method before `reset()`.

            Args:
                input_vector: Input vector controlling the CPPN
                water_level: Water level between 0.0 (no water at all) and 1.0 (full of water)
                creepers_width: Width of creepers
                creepers_height: Mean of creepers&#39; height (height is then sample using a normal distribution with a 0.1 std for each creeper)
                creepers_spacing: Spacing between creepers
                terrain_cppn_scale: How much values outputted by the CPNN must be scaled (default 10)
        &#39;&#39;&#39;
        self.CPPN_input_vector = input_vector
        self.water_level = water_level.item() if isinstance(water_level, np.float32) else water_level
        self.water_level = max(0.01, self.water_level)
        self.creepers_width = creepers_width if creepers_width is not None else creepers_width
        self.creepers_height = creepers_height if creepers_height is not None else creepers_height
        self.creepers_spacing = max(0.01, creepers_spacing)
        self.set_terrain_cppn_scale(terrain_cppn_scale,
                                    self.ceiling_offset*self.TERRAIN_CPPN_SCALE,
                                    self.ceiling_clip_offset*self.TERRAIN_CPPN_SCALE)

    def _destroy(self):
        # if not self.terrain: return
        for t in self.terrain:
            self.world.DestroyBody(t)
        self.terrain = []

        self.agent_body.destroy(self.world)

    def reset(self):
        self.world.contactListener = None
        self.contact_listener.Reset()
        self._destroy()
        self.world.contactListener = self.contact_listener
        self.critical_contact = False
        self.prev_shaping = None
        self.scroll = [0.0, 0.0]
        self.lidar_render = 0
        self.water_y = self.GROUND_LIMIT
        self.nb_steps_outside_water = 0
        self.nb_steps_under_water = 0

        self.generate_game()

        self.drawlist = self.terrain + self.agent_body.get_elements_to_render()

        self.lidar = [LidarCallback(self.agent_body.reference_head_object.fixtures[0].filterData.maskBits)
                      for _ in range(NB_LIDAR)]

        actions_to_play = np.array([0] * self.action_space.shape[0])
        # If embodiment is a climber, make it start hanging on the ceiling using a few steps to let the Box2D solver handle positions.
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            # Init climber
            y_diff = 0
            for i in range(len(self.agent_body.sensors)):
                actions_to_play[len(actions_to_play) - i - 1] = 1
                # Hang sensor
                sensor = self.agent_body.sensors[len(self.agent_body.sensors) - i - 1]
                if y_diff == 0:
                    y_diff = TERRAIN_HEIGHT + self.ceiling_offset - sensor.position[1]
                sensor.position = (sensor.position[0],
                                   TERRAIN_HEIGHT + self.ceiling_offset)

            for body_part in self.agent_body.body_parts:
                body_part.position = (body_part.position[0],
                                      body_part.position[1] + y_diff)

            for i in range(NB_FIRST_STEPS_HANG):
                self.step(actions_to_play)

        initial_state = self.step(actions_to_play)[0]
        self.nb_steps_outside_water = 0
        self.nb_steps_under_water = 0
        self.episodic_reward = 0
        return initial_state

    def step(self, action):
        # Check if agent&#39;s dead
        if hasattr(self.agent_body, &#34;nb_steps_can_survive_outside_water&#34;) and \
                        self.nb_steps_outside_water &gt; self.agent_body.nb_steps_can_survive_outside_water or \
                        hasattr(self.agent_body, &#34;nb_steps_can_survive_under_water&#34;) and \
                                self.nb_steps_under_water &gt; self.agent_body.nb_steps_can_survive_under_water:
            is_agent_dead = True
            action = np.array([0] * self.action_space.shape[0])
        else:
            is_agent_dead = False
        self.agent_body.activate_motors(action)

        # Prepare climbing dynamics according to the actions (i.e. sensor ready to grasp or sensor release destroying joint)
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            self.climbing_dynamics.before_step_climbing_dynamics(action, self.agent_body, self.world)

        self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)

        # Create joints between sensors ready to grasp if collision with graspable area was detected
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            self.climbing_dynamics.after_step_climbing_dynamics(self.world.contactListener, self.world)

        # Calculate water physics
        self.water_dynamics.calculate_forces(self.world.contactListener.fixture_pairs)

        head = self.agent_body.reference_head_object
        pos = head.position
        vel = head.linearVelocity

        for i in range(NB_LIDAR):
            self.lidar[i].fraction = 1.0
            self.lidar[i].p1 = pos
            self.lidar[i].p2 = (
                pos[0] + math.sin((self.lidar_angle * i / NB_LIDAR + self.lidar_y_offset)) * LIDAR_RANGE,
                pos[1] - math.cos((self.lidar_angle * i / NB_LIDAR) + self.lidar_y_offset) * LIDAR_RANGE)
            self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)

        is_under_water = pos.y &lt;= self.water_y
        if not is_agent_dead:
            if is_under_water:
                self.nb_steps_under_water += 1
                self.nb_steps_outside_water = 0
            else:
                self.nb_steps_outside_water += 1
                self.nb_steps_under_water = 0

        state = [
            head.angle,  # Normal angles up to 0.5 here, but sure more is possible.
            2.0 * head.angularVelocity / FPS,
            0.3 * vel.x * (VIEWPORT_W / SCALE) / FPS,  # Normalized to get -1..1 range
            0.3 * vel.y * (VIEWPORT_H / SCALE) / FPS,
            1.0 if is_under_water else 0.0,
            1.0 if is_agent_dead else 0.0
        ]

        # add leg-related state
        state.extend(self.agent_body.get_motors_state())

        # add sensor-related state
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            state.extend(self.agent_body.get_sensors_state())

        # add lidar-related state with distance and surface detected
        nb_of_water_detected = 0
        surface_dectected = []
        for lidar in self.lidar:
            state.append(lidar.fraction)
            if lidar.is_water_detected:
                surface_dectected.append(-1)
                nb_of_water_detected += 1
            elif lidar.is_creeper_detected:
                surface_dectected.append(1)
            else:
                surface_dectected.append(0)

        # state.append(nb_of_water_detected / NB_LIDAR)  # percentage of lidars that detect water
        state.extend(surface_dectected)

        self.scroll = [pos[0] - RENDERING_VIEWER_W / SCALE / 5,
                       pos[1] - RENDERING_VIEWER_H / SCALE / 5 - TERRAIN_HEIGHT + 1 / SCALE]  # 1 = grass

        shaping = 130 * pos[
            0] / SCALE  # moving forward is a way to receive reward (normalized to get 300 on completion)
        if not (
            hasattr(self.agent_body, &#34;remove_reward_on_head_angle&#34;) and self.agent_body.remove_reward_on_head_angle):
            shaping -= 5.0 * abs(
                state[0])  # keep head straight, other than that and falling, any behavior is unpunished

        reward = 0
        if self.prev_shaping is not None:
            reward = shaping - self.prev_shaping
        self.prev_shaping = shaping

        for a in action:
            reward -= self.agent_body.TORQUE_PENALTY * 80 * np.clip(np.abs(a), 0, 1)  # 80 =&gt; Original torque
            # normalized to about -50.0 using heuristic, more optimal agent should spend less

        # Ending conditions
        done = False
        if self.critical_contact or pos[0] &lt; 0:
            reward = -100
            done = True
        if pos[0] &gt; (TERRAIN_LENGTH + self.TERRAIN_STARTPAD - TERRAIN_END) * TERRAIN_STEP:
            done = True
        self.episodic_reward += reward

        return np.array(state), reward, done, {&#34;success&#34;: self.episodic_reward &gt; 230}

    def close(self):
        self.world.contactListener = None
        self.contact_listener.Reset()
        self._destroy()
        if self.viewer is not None:
            self.viewer.close()
            self.viewer = None

    # region Rendering
    # ------------------------------------------ RENDERING ------------------------------------------
    def color_agent_head(self, c1, c2):
        &#39;&#39;&#39;
            Color agent&#39;s head depending on its &#39;dying&#39; state.
        &#39;&#39;&#39;
        ratio = 0
        if hasattr(self.agent_body, &#34;nb_steps_can_survive_outside_water&#34;):
            ratio = self.nb_steps_outside_water / self.agent_body.nb_steps_can_survive_outside_water
        elif hasattr(self.agent_body, &#34;nb_steps_can_survive_under_water&#34;):
            ratio = self.nb_steps_under_water / self.agent_body.nb_steps_can_survive_under_water

        color1 = (c1[0] + ratio*(1.0 - c1[0]),
                  c1[1] + ratio*(0.0 - c1[1]),
                  c1[2] + ratio*(0.0 - c1[2]))
        color2 = c2
        return color1, color2

    def render(self, mode=&#39;human&#39;, draw_lidars=True):
        from gym.envs.classic_control import rendering
        if self.viewer is None:
            self.viewer = rendering.Viewer(RENDERING_VIEWER_W, RENDERING_VIEWER_H)
        self.viewer.set_bounds(self.scroll[0], RENDERING_VIEWER_W/SCALE + self.scroll[0], # x
                               self.scroll[1], RENDERING_VIEWER_H/SCALE + self.scroll[1]) # y

        self.viewer.draw_polygon( [
            (self.scroll[0], self.scroll[1]),
            (self.scroll[0]+RENDERING_VIEWER_W/SCALE, self.scroll[1]),
            (self.scroll[0]+RENDERING_VIEWER_W/SCALE, self.scroll[1]+RENDERING_VIEWER_H/SCALE),
            (self.scroll[0], self.scroll[1]+RENDERING_VIEWER_H/SCALE),
            ], color=(0.9, 0.9, 1.0) )

        for poly,x1,x2 in self.cloud_poly:
            if x2 &lt; self.scroll[0]/2: continue
            if x1 &gt; self.scroll[0]/2 + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon( [(p[0]+self.scroll[0]/2, p[1]) for p in poly], color=(1,1,1))

        for obj in self.drawlist:
            color1 = obj.color1
            color2 = obj.color2
            if obj.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and obj.userData.has_joint: # Color sensors when attached
                color1 = (1.0, 1.0, 0.0)
                color2 = (1.0, 1.0, 0.0)
            elif obj == self.agent_body.reference_head_object:
                color1, color2 = self.color_agent_head(color1, color2)

            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans*f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans*v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=color1)
                    path.append(path[0])
                    self.viewer.draw_polyline(path, color=color2, linewidth=2)

        for poly, color in self.terrain_poly:
            if poly[1][0] &lt; self.scroll[0]: continue
            if poly[0][0] &gt; self.scroll[0] + RENDERING_VIEWER_W / SCALE: continue
            self.viewer.draw_polygon(poly, color=color)

        # Draw lidars
        if draw_lidars:
            for i in range(len(self.lidar)):
                l = self.lidar[i]
                self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

        flagy1 = TERRAIN_HEIGHT
        flagy2 = flagy1 + 50/SCALE
        x = TERRAIN_STEP*3
        self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
        f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
        self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
        self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

        return self.viewer.render(return_rgb_array = mode==&#39;rgb_array&#39;)

    def _SET_RENDERING_VIEWPORT_SIZE(self, width, height=None, keep_ratio=True):
        &#39;&#39;&#39;
            Set rendering viewport&#39;s size (i.e. image size).

            Args:
                width: viewport&#39;s width
                height: viewport&#39;s height
                keep_ratio: Whether height must be automatically calculated to keep the same ratio as the environment&#39;s viewport size.
        &#39;&#39;&#39;
        global RENDERING_VIEWER_W, RENDERING_VIEWER_H
        RENDERING_VIEWER_W = width
        if keep_ratio or height is None:
            RENDERING_VIEWER_H = int(RENDERING_VIEWER_W / (VIEWPORT_W / VIEWPORT_H))
        else:
            RENDERING_VIEWER_H = height
    #endregion

    #region Fixtures Initialization
    # ------------------------------------------ FIXTURES INITIALIZATION ------------------------------------------

    def create_terrain_fixtures(self):
        &#39;&#39;&#39;
            Create fixtures used to generate terrain.
        &#39;&#39;&#39;
        self.fd_polygon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        self.fd_edge = fixtureDef(
            shape=edgeShape(vertices=
                            [(0, 0),
                             (1, 1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        self.fd_water = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            density=WATER_DENSITY,
            isSensor=True
        )

        self.fd_creeper = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            density=5.0,
            isSensor=True,
        )
    #endregion

    # region Game Generation
    # ------------------------------------------ GAME GENERATION ------------------------------------------

    def generate_game(self):
        &#39;&#39;&#39;
            Generate the task (i.e. terrain + embodiment).
        &#39;&#39;&#39;
        self._generate_terrain()
        self._generate_clouds()
        self._generate_agent()

    def clip_ceiling_values(self, row, clip_offset):
        if row[&#34;ceiling&#34;] &gt;= row[&#34;ground&#34;] + clip_offset:
            return row[&#34;ceiling&#34;]
        else:
            return row[&#34;ground&#34;] + clip_offset

    def _generate_terrain(self):
        y = self.terrain_CPPN.generate(self.CPPN_input_vector)
        y = y / self.TERRAIN_CPPN_SCALE
        ground_y = y[:, 0]
        ceiling_y = y[:, 1]

        # Align ground with startpad
        offset = TERRAIN_HEIGHT - ground_y[0]
        ground_y = np.add(ground_y, offset)

        # Align ceiling from startpad ceiling
        offset = TERRAIN_HEIGHT + self.ceiling_offset - ceiling_y[0]
        ceiling_y = np.add(ceiling_y, offset)

        self.terrain = []
        self.terrain_x = []
        self.terrain_ground_y = []
        self.terrain_ceiling_y = []
        terrain_creepers = []
        water_body = None
        x = 0
        max_x = TERRAIN_LENGTH * TERRAIN_STEP + self.TERRAIN_STARTPAD * TERRAIN_STEP

        # Generation of terrain
        i = 0
        while x &lt; max_x:
            self.terrain_x.append(x)
            if i &lt; self.TERRAIN_STARTPAD:
                self.terrain_ground_y.append(TERRAIN_HEIGHT)
                self.terrain_ceiling_y.append(TERRAIN_HEIGHT + self.ceiling_offset)
            else:
                self.terrain_ground_y.append(ground_y[i - self.TERRAIN_STARTPAD].item())

                # Clip ceiling
                if ceiling_y[i - self.TERRAIN_STARTPAD] &gt;= ground_y[i - self.TERRAIN_STARTPAD] + self.ceiling_clip_offset:
                    ceiling_val = ceiling_y[i - self.TERRAIN_STARTPAD]
                else:
                    ceiling_val = ground_y[i - self.TERRAIN_STARTPAD] + self.ceiling_clip_offset

                self.terrain_ceiling_y.append(ceiling_val.item())

            x += TERRAIN_STEP
            i += 1

        # Draw terrain
        space_from_precedent_creeper = self.creepers_spacing
        self.terrain_poly = []
        for i in range(len(self.terrain_x) - 1):
            # Ground
            poly = [
                (self.terrain_x[i], self.terrain_ground_y[i]),
                (self.terrain_x[i + 1], self.terrain_ground_y[i + 1])
            ]
            self.fd_edge.shape.vertices = poly
            t = self.world.CreateStaticBody(
                fixtures=self.fd_edge,
                userData=CustomUserData(&#34;grass&#34;, CustomUserDataObjectTypes.TERRAIN))
            color = (0.3, 1.0 if (i % 2) == 0 else 0.8, 0.3)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.4, 0.6, 0.3)
            poly += [(poly[1][0], self.GROUND_LIMIT), (poly[0][0], self.GROUND_LIMIT)]
            self.terrain_poly.append((poly, color))

            # Ceiling
            poly = [
                (self.terrain_x[i], self.terrain_ceiling_y[i]),
                (self.terrain_x[i + 1], self.terrain_ceiling_y[i + 1])
            ]
            self.fd_edge.shape.vertices = poly
            t = self.world.CreateStaticBody(
                fixtures=self.fd_edge,
                userData=CustomUserData(&#34;rock&#34;, CustomUserDataObjectTypes.GRIP_TERRAIN))
            color = (0, 0.25, 0.25)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.5, 0.5, 0.5)
            poly += [(poly[1][0], self.CEILING_LIMIT), (poly[0][0], self.CEILING_LIMIT)]
            self.terrain_poly.append((poly, color))

            # Creepers
            if self.creepers_width is not None and self.creepers_height is not None:
                if space_from_precedent_creeper &gt;= self.creepers_spacing:
                    creeper_height = max(0.2, self.np_random.normal(self.creepers_height, 0.1))
                    creeper_width = max(0.2, self.creepers_width)
                    creeper_step_size = np.floor(creeper_width / TERRAIN_STEP).astype(int)
                    creeper_step_size = max(1, creeper_step_size)
                    creeper_y_init_pos = max(self.terrain_ceiling_y[i],
                                             self.terrain_ceiling_y[min(i + creeper_step_size, len(self.terrain_x) - 1)])
                    if self.movable_creepers: # Break down creepers into multiple objects linked by joints
                        previous_creeper_part = t
                        for w in range(math.ceil(creeper_height)):
                            if w == creeper_height // 1:
                                h = max(0.2, creeper_height % 1)
                            else:
                                h = 1

                            poly = [
                                (self.terrain_x[i] + creeper_width, creeper_y_init_pos - (w * 1) - h),
                                (self.terrain_x[i] + creeper_width, creeper_y_init_pos - (w * 1)),
                                (self.terrain_x[i], creeper_y_init_pos - (w * 1)),
                                (self.terrain_x[i], creeper_y_init_pos - (w * 1) - h)
                            ]
                            self.fd_creeper.shape.vertices = poly
                            t = self.world.CreateDynamicBody(
                                fixtures=self.fd_creeper,
                                userData=CustomUserData(&#34;creeper&#34;, CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN))
                            c = (0.437, 0.504, 0.375)
                            t.color1 = c
                            t.color2 = tuple([_c+0.1 for _c  in c])
                            self.terrain.append(t)

                            rjd = revoluteJointDef(
                                bodyA=previous_creeper_part,
                                bodyB=t,
                                anchor=(self.terrain_x[i] + creeper_width / 2, creeper_y_init_pos - (w * 1)),
                                enableLimit=True,
                                lowerAngle=-0.4 * np.pi,
                                upperAngle=0.4 * np.pi,
                            )
                            self.world.CreateJoint(rjd)
                            previous_creeper_part = t
                    else:
                        poly = [
                            (self.terrain_x[i], creeper_y_init_pos),
                            (self.terrain_x[i] + creeper_width, creeper_y_init_pos),
                            (self.terrain_x[i] + creeper_width, creeper_y_init_pos - creeper_height),
                            (self.terrain_x[i], creeper_y_init_pos - creeper_height),
                        ]
                        self.fd_creeper.shape.vertices = poly
                        t = self.world.CreateStaticBody(
                            fixtures=self.fd_creeper,
                            userData=CustomUserData(&#34;creeper&#34;, CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN))
                        c = (0.437, 0.504, 0.375)
                        t.color1 = c
                        t.color2 = c
                        terrain_creepers.append(t)
                    space_from_precedent_creeper = 0
                else:
                    space_from_precedent_creeper += self.terrain_x[i] - self.terrain_x[i - 1]

        # Water
        # Fill water from GROUND_LIMIT to highest point of the current ceiling
        air_max_distance = max(self.terrain_ceiling_y) - self.GROUND_LIMIT
        water_y = self.GROUND_LIMIT + self.water_level * air_max_distance
        self.water_y = water_y

        water_poly = [
            (self.terrain_x[0], self.GROUND_LIMIT),
            (self.terrain_x[0], water_y),
            (self.terrain_x[len(self.terrain_x) - 1], water_y),
            (self.terrain_x[len(self.terrain_x) - 1], self.GROUND_LIMIT)
        ]
        self.fd_water.shape.vertices = water_poly
        t = self.world.CreateStaticBody(
            fixtures=self.fd_water,
            userData=CustomUserData(&#34;water&#34;, CustomUserDataObjectTypes.WATER))
        c = (0.465, 0.676, 0.898)
        t.color1 = c
        t.color2 = c
        water_body = t

        self.terrain.extend(terrain_creepers)
        if water_body is not None:
            self.terrain.append(water_body)
        self.terrain.reverse()


    def _generate_clouds(self):
        self.cloud_poly   = []
        for i in range(TERRAIN_LENGTH//20):
            x = self.np_random.uniform(0, TERRAIN_LENGTH)*TERRAIN_STEP
            y = VIEWPORT_H/SCALE*3/4
            poly = [
                (x+15*TERRAIN_STEP*math.sin(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP),
                 y+ 5*TERRAIN_STEP*math.cos(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP) )
                for a in range(5) ]
            x1 = min( [p[0] for p in poly] )
            x2 = max( [p[0] for p in poly] )
            self.cloud_poly.append( (poly,x1,x2) )

    def _generate_agent(self):
        init_x = TERRAIN_STEP*self.TERRAIN_STARTPAD/2
        init_y = TERRAIN_HEIGHT + self.agent_body.AGENT_CENTER_HEIGHT # set y position according to the agent

        self.agent_body.draw(
            self.world,
            init_x,
            init_y,
            self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gym.core.Env</li>
<li>gym.utils.ezpickle.EzPickle</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.clip_ceiling_values"><code class="name flex">
<span>def <span class="ident">clip_ceiling_values</span></span>(<span>self, row, clip_offset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clip_ceiling_values(self, row, clip_offset):
    if row[&#34;ceiling&#34;] &gt;= row[&#34;ground&#34;] + clip_offset:
        return row[&#34;ceiling&#34;]
    else:
        return row[&#34;ground&#34;] + clip_offset</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Override close in your subclass to perform any necessary cleanup.</p>
<p>Environments will automatically close() themselves when
garbage collected or when the program exits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self.world.contactListener = None
    self.contact_listener.Reset()
    self._destroy()
    if self.viewer is not None:
        self.viewer.close()
        self.viewer = None</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.color_agent_head"><code class="name flex">
<span>def <span class="ident">color_agent_head</span></span>(<span>self, c1, c2)</span>
</code></dt>
<dd>
<div class="desc"><p>Color agent's head depending on its 'dying' state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color_agent_head(self, c1, c2):
    &#39;&#39;&#39;
        Color agent&#39;s head depending on its &#39;dying&#39; state.
    &#39;&#39;&#39;
    ratio = 0
    if hasattr(self.agent_body, &#34;nb_steps_can_survive_outside_water&#34;):
        ratio = self.nb_steps_outside_water / self.agent_body.nb_steps_can_survive_outside_water
    elif hasattr(self.agent_body, &#34;nb_steps_can_survive_under_water&#34;):
        ratio = self.nb_steps_under_water / self.agent_body.nb_steps_can_survive_under_water

    color1 = (c1[0] + ratio*(1.0 - c1[0]),
              c1[1] + ratio*(0.0 - c1[1]),
              c1[2] + ratio*(0.0 - c1[2]))
    color2 = c2
    return color1, color2</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.create_terrain_fixtures"><code class="name flex">
<span>def <span class="ident">create_terrain_fixtures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create fixtures used to generate terrain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_terrain_fixtures(self):
    &#39;&#39;&#39;
        Create fixtures used to generate terrain.
    &#39;&#39;&#39;
    self.fd_polygon = fixtureDef(
        shape=polygonShape(vertices=
                           [(0, 0),
                            (1, 0),
                            (1, -1),
                            (0, -1)]),
        friction=FRICTION,
        categoryBits=0x1,
        maskBits=0xFFFF
    )

    self.fd_edge = fixtureDef(
        shape=edgeShape(vertices=
                        [(0, 0),
                         (1, 1)]),
        friction=FRICTION,
        categoryBits=0x1,
        maskBits=0xFFFF
    )

    self.fd_water = fixtureDef(
        shape=polygonShape(vertices=
                           [(0, 0),
                            (1, 0),
                            (1, -1),
                            (0, -1)]),
        density=WATER_DENSITY,
        isSensor=True
    )

    self.fd_creeper = fixtureDef(
        shape=polygonShape(vertices=
                           [(0, 0),
                            (1, 0),
                            (1, -1),
                            (0, -1)]),
        density=5.0,
        isSensor=True,
    )</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.generate_game"><code class="name flex">
<span>def <span class="ident">generate_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the task (i.e. terrain + embodiment).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_game(self):
    &#39;&#39;&#39;
        Generate the task (i.e. terrain + embodiment).
    &#39;&#39;&#39;
    self._generate_terrain()
    self._generate_clouds()
    self._generate_agent()</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, mode='human', draw_lidars=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Renders the environment.</p>
<p>The set of supported modes varies per environment. (And some
environments do not support rendering at all.) By convention,
if mode is:</p>
<ul>
<li>human: render to the current display or terminal and
return nothing. Usually for human consumption.</li>
<li>rgb_array: Return an numpy.ndarray with shape (x, y, 3),
representing RGB values for an x-by-y pixel image, suitable
for turning into a video.</li>
<li>ansi: Return a string (str) or StringIO.StringIO containing a
terminal-style text representation. The text can include newlines
and ANSI escape sequences (e.g. for colors).</li>
</ul>
<h2 id="note">Note</h2>
<p>Make sure that your class's metadata 'render.modes' key includes
the list of supported modes. It's recommended to call super()
in implementations to use the functionality of this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>the mode to render with</dd>
</dl>
<p>Example:</p>
<p>class MyEnv(Env):
metadata = {'render.modes': ['human', 'rgb_array']}</p>
<pre><code>def render(self, mode='human'):
    if mode == 'rgb_array':
        return np.array(...) # return RGB frame suitable for video
    elif mode == 'human':
        ... # pop up a window and render
    else:
        super(MyEnv, self).render(mode=mode) # just raise an exception
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, mode=&#39;human&#39;, draw_lidars=True):
    from gym.envs.classic_control import rendering
    if self.viewer is None:
        self.viewer = rendering.Viewer(RENDERING_VIEWER_W, RENDERING_VIEWER_H)
    self.viewer.set_bounds(self.scroll[0], RENDERING_VIEWER_W/SCALE + self.scroll[0], # x
                           self.scroll[1], RENDERING_VIEWER_H/SCALE + self.scroll[1]) # y

    self.viewer.draw_polygon( [
        (self.scroll[0], self.scroll[1]),
        (self.scroll[0]+RENDERING_VIEWER_W/SCALE, self.scroll[1]),
        (self.scroll[0]+RENDERING_VIEWER_W/SCALE, self.scroll[1]+RENDERING_VIEWER_H/SCALE),
        (self.scroll[0], self.scroll[1]+RENDERING_VIEWER_H/SCALE),
        ], color=(0.9, 0.9, 1.0) )

    for poly,x1,x2 in self.cloud_poly:
        if x2 &lt; self.scroll[0]/2: continue
        if x1 &gt; self.scroll[0]/2 + RENDERING_VIEWER_W/SCALE: continue
        self.viewer.draw_polygon( [(p[0]+self.scroll[0]/2, p[1]) for p in poly], color=(1,1,1))

    for obj in self.drawlist:
        color1 = obj.color1
        color2 = obj.color2
        if obj.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and obj.userData.has_joint: # Color sensors when attached
            color1 = (1.0, 1.0, 0.0)
            color2 = (1.0, 1.0, 0.0)
        elif obj == self.agent_body.reference_head_object:
            color1, color2 = self.color_agent_head(color1, color2)

        for f in obj.fixtures:
            trans = f.body.transform
            if type(f.shape) is circleShape:
                t = rendering.Transform(translation=trans*f.shape.pos)
                self.viewer.draw_circle(f.shape.radius, 30, color=color1).add_attr(t)
                self.viewer.draw_circle(f.shape.radius, 30, color=color2, filled=False, linewidth=2).add_attr(t)
            else:
                path = [trans*v for v in f.shape.vertices]
                self.viewer.draw_polygon(path, color=color1)
                path.append(path[0])
                self.viewer.draw_polyline(path, color=color2, linewidth=2)

    for poly, color in self.terrain_poly:
        if poly[1][0] &lt; self.scroll[0]: continue
        if poly[0][0] &gt; self.scroll[0] + RENDERING_VIEWER_W / SCALE: continue
        self.viewer.draw_polygon(poly, color=color)

    # Draw lidars
    if draw_lidars:
        for i in range(len(self.lidar)):
            l = self.lidar[i]
            self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

    flagy1 = TERRAIN_HEIGHT
    flagy2 = flagy1 + 50/SCALE
    x = TERRAIN_STEP*3
    self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
    f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
    self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
    self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

    return self.viewer.render(return_rgb_array = mode==&#39;rgb_array&#39;)</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the environment to an initial state and returns an initial
observation.</p>
<p>Note that this function should not reset the environment's random
number generator(s); random variables in the environment's state should
be sampled independently between multiple calls to <code>reset()</code>. In other
words, each call of <code>reset()</code> should yield an environment suitable for
a new episode, independent of previous episodes.</p>
<h2 id="returns">Returns</h2>
<p>observation (object): the initial observation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.world.contactListener = None
    self.contact_listener.Reset()
    self._destroy()
    self.world.contactListener = self.contact_listener
    self.critical_contact = False
    self.prev_shaping = None
    self.scroll = [0.0, 0.0]
    self.lidar_render = 0
    self.water_y = self.GROUND_LIMIT
    self.nb_steps_outside_water = 0
    self.nb_steps_under_water = 0

    self.generate_game()

    self.drawlist = self.terrain + self.agent_body.get_elements_to_render()

    self.lidar = [LidarCallback(self.agent_body.reference_head_object.fixtures[0].filterData.maskBits)
                  for _ in range(NB_LIDAR)]

    actions_to_play = np.array([0] * self.action_space.shape[0])
    # If embodiment is a climber, make it start hanging on the ceiling using a few steps to let the Box2D solver handle positions.
    if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
        # Init climber
        y_diff = 0
        for i in range(len(self.agent_body.sensors)):
            actions_to_play[len(actions_to_play) - i - 1] = 1
            # Hang sensor
            sensor = self.agent_body.sensors[len(self.agent_body.sensors) - i - 1]
            if y_diff == 0:
                y_diff = TERRAIN_HEIGHT + self.ceiling_offset - sensor.position[1]
            sensor.position = (sensor.position[0],
                               TERRAIN_HEIGHT + self.ceiling_offset)

        for body_part in self.agent_body.body_parts:
            body_part.position = (body_part.position[0],
                                  body_part.position[1] + y_diff)

        for i in range(NB_FIRST_STEPS_HANG):
            self.step(actions_to_play)

    initial_state = self.step(actions_to_play)[0]
    self.nb_steps_outside_water = 0
    self.nb_steps_under_water = 0
    self.episodic_reward = 0
    return initial_state</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>self, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the seed for this env's random number generator(s).</p>
<h2 id="note">Note</h2>
<p>Some environments use multiple pseudorandom number generators.
We want to capture all such seeds used in order to ensure that
there aren't accidental correlations between multiple generators.</p>
<h2 id="returns">Returns</h2>
<p>list<bigint>: Returns the list of seeds used in this env's random
number generators. The first value in the list should be the
"main" seed, or the value which a reproducer should pass to
'seed'. Often, the main seed equals the provided 'seed', but
this won't be true if seed=None, for example.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed(self, seed=None):
    self.np_random, seed = seeding.np_random(seed)
    return [seed]</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.set_environment"><code class="name flex">
<span>def <span class="ident">set_environment</span></span>(<span>self, input_vector, water_level, creepers_width=None, creepers_height=None, creepers_spacing=0.1, terrain_cppn_scale=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the parameters controlling the PCG algorithm to generate a task.
Call this method before <code>reset()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_vector</code></strong></dt>
<dd>Input vector controlling the CPPN</dd>
<dt><strong><code>water_level</code></strong></dt>
<dd>Water level between 0.0 (no water at all) and 1.0 (full of water)</dd>
<dt><strong><code>creepers_width</code></strong></dt>
<dd>Width of creepers</dd>
<dt><strong><code>creepers_height</code></strong></dt>
<dd>Mean of creepers' height (height is then sample using a normal distribution with a 0.1 std for each creeper)</dd>
<dt><strong><code>creepers_spacing</code></strong></dt>
<dd>Spacing between creepers</dd>
<dt><strong><code>terrain_cppn_scale</code></strong></dt>
<dd>How much values outputted by the CPNN must be scaled (default 10)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_environment(self, input_vector, water_level, creepers_width=None, creepers_height=None,
                    creepers_spacing=0.1, terrain_cppn_scale=10):
    &#39;&#39;&#39;
        Set the parameters controlling the PCG algorithm to generate a task.
        Call this method before `reset()`.

        Args:
            input_vector: Input vector controlling the CPPN
            water_level: Water level between 0.0 (no water at all) and 1.0 (full of water)
            creepers_width: Width of creepers
            creepers_height: Mean of creepers&#39; height (height is then sample using a normal distribution with a 0.1 std for each creeper)
            creepers_spacing: Spacing between creepers
            terrain_cppn_scale: How much values outputted by the CPNN must be scaled (default 10)
    &#39;&#39;&#39;
    self.CPPN_input_vector = input_vector
    self.water_level = water_level.item() if isinstance(water_level, np.float32) else water_level
    self.water_level = max(0.01, self.water_level)
    self.creepers_width = creepers_width if creepers_width is not None else creepers_width
    self.creepers_height = creepers_height if creepers_height is not None else creepers_height
    self.creepers_spacing = max(0.01, creepers_spacing)
    self.set_terrain_cppn_scale(terrain_cppn_scale,
                                self.ceiling_offset*self.TERRAIN_CPPN_SCALE,
                                self.ceiling_clip_offset*self.TERRAIN_CPPN_SCALE)</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.set_terrain_cppn_scale"><code class="name flex">
<span>def <span class="ident">set_terrain_cppn_scale</span></span>(<span>self, terrain_cppn_scale, ceiling_offset, ceiling_clip_offset)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale the terrain generated by the CPPN to be more suited to our embodiments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_terrain_cppn_scale(self, terrain_cppn_scale, ceiling_offset, ceiling_clip_offset):
    &#39;&#39;&#39;
        Scale the terrain generated by the CPPN to be more suited to our embodiments.
    &#39;&#39;&#39;
    assert terrain_cppn_scale &gt; 1
    self.TERRAIN_CPPN_SCALE = terrain_cppn_scale
    self.CEILING_LIMIT = 1000 / self.TERRAIN_CPPN_SCALE
    self.GROUND_LIMIT = -1000 / self.TERRAIN_CPPN_SCALE
    self.ceiling_offset = ceiling_offset / self.TERRAIN_CPPN_SCALE
    self.ceiling_clip_offset = ceiling_clip_offset / self.TERRAIN_CPPN_SCALE</code></pre>
</details>
</dd>
<dt id="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<div class="desc"><p>Run one timestep of the environment's dynamics. When end of
episode is reached, you are responsible for calling <code>reset()</code>
to reset this environment's state.</p>
<p>Accepts an action and returns a tuple (observation, reward, done, info).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>object</code></dt>
<dd>an action provided by the agent</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>observation (object): agent's observation of the current environment
reward (float) : amount of reward returned after previous action
done (bool): whether the episode has ended, in which case further step() calls will return undefined results
info (dict): contains auxiliary diagnostic information (helpful for debugging, and sometimes learning)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, action):
    # Check if agent&#39;s dead
    if hasattr(self.agent_body, &#34;nb_steps_can_survive_outside_water&#34;) and \
                    self.nb_steps_outside_water &gt; self.agent_body.nb_steps_can_survive_outside_water or \
                    hasattr(self.agent_body, &#34;nb_steps_can_survive_under_water&#34;) and \
                            self.nb_steps_under_water &gt; self.agent_body.nb_steps_can_survive_under_water:
        is_agent_dead = True
        action = np.array([0] * self.action_space.shape[0])
    else:
        is_agent_dead = False
    self.agent_body.activate_motors(action)

    # Prepare climbing dynamics according to the actions (i.e. sensor ready to grasp or sensor release destroying joint)
    if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
        self.climbing_dynamics.before_step_climbing_dynamics(action, self.agent_body, self.world)

    self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)

    # Create joints between sensors ready to grasp if collision with graspable area was detected
    if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
        self.climbing_dynamics.after_step_climbing_dynamics(self.world.contactListener, self.world)

    # Calculate water physics
    self.water_dynamics.calculate_forces(self.world.contactListener.fixture_pairs)

    head = self.agent_body.reference_head_object
    pos = head.position
    vel = head.linearVelocity

    for i in range(NB_LIDAR):
        self.lidar[i].fraction = 1.0
        self.lidar[i].p1 = pos
        self.lidar[i].p2 = (
            pos[0] + math.sin((self.lidar_angle * i / NB_LIDAR + self.lidar_y_offset)) * LIDAR_RANGE,
            pos[1] - math.cos((self.lidar_angle * i / NB_LIDAR) + self.lidar_y_offset) * LIDAR_RANGE)
        self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)

    is_under_water = pos.y &lt;= self.water_y
    if not is_agent_dead:
        if is_under_water:
            self.nb_steps_under_water += 1
            self.nb_steps_outside_water = 0
        else:
            self.nb_steps_outside_water += 1
            self.nb_steps_under_water = 0

    state = [
        head.angle,  # Normal angles up to 0.5 here, but sure more is possible.
        2.0 * head.angularVelocity / FPS,
        0.3 * vel.x * (VIEWPORT_W / SCALE) / FPS,  # Normalized to get -1..1 range
        0.3 * vel.y * (VIEWPORT_H / SCALE) / FPS,
        1.0 if is_under_water else 0.0,
        1.0 if is_agent_dead else 0.0
    ]

    # add leg-related state
    state.extend(self.agent_body.get_motors_state())

    # add sensor-related state
    if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
        state.extend(self.agent_body.get_sensors_state())

    # add lidar-related state with distance and surface detected
    nb_of_water_detected = 0
    surface_dectected = []
    for lidar in self.lidar:
        state.append(lidar.fraction)
        if lidar.is_water_detected:
            surface_dectected.append(-1)
            nb_of_water_detected += 1
        elif lidar.is_creeper_detected:
            surface_dectected.append(1)
        else:
            surface_dectected.append(0)

    # state.append(nb_of_water_detected / NB_LIDAR)  # percentage of lidars that detect water
    state.extend(surface_dectected)

    self.scroll = [pos[0] - RENDERING_VIEWER_W / SCALE / 5,
                   pos[1] - RENDERING_VIEWER_H / SCALE / 5 - TERRAIN_HEIGHT + 1 / SCALE]  # 1 = grass

    shaping = 130 * pos[
        0] / SCALE  # moving forward is a way to receive reward (normalized to get 300 on completion)
    if not (
        hasattr(self.agent_body, &#34;remove_reward_on_head_angle&#34;) and self.agent_body.remove_reward_on_head_angle):
        shaping -= 5.0 * abs(
            state[0])  # keep head straight, other than that and falling, any behavior is unpunished

    reward = 0
    if self.prev_shaping is not None:
        reward = shaping - self.prev_shaping
    self.prev_shaping = shaping

    for a in action:
        reward -= self.agent_body.TORQUE_PENALTY * 80 * np.clip(np.abs(a), 0, 1)  # 80 =&gt; Original torque
        # normalized to about -50.0 using heuristic, more optimal agent should spend less

    # Ending conditions
    done = False
    if self.critical_contact or pos[0] &lt; 0:
        reward = -100
        done = True
    if pos[0] &gt; (TERRAIN_LENGTH + self.TERRAIN_STARTPAD - TERRAIN_END) * TERRAIN_STEP:
        done = True
    self.episodic_reward += reward

    return np.array(state), reward, done, {&#34;success&#34;: self.episodic_reward &gt; 230}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="http://developmentalsystems.org/TeachMyAgent/">
<img src="https://github.com/flowersteam/TeachMyAgent/blob/gh-pages/images/home/head_image.png?raw=true" style="display: block; margin: 1em auto">
</a>
<a href="http://developmentalsystems.org/TeachMyAgent/">Website</a>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="TeachMyAgent.environments.envs" href="index.html">TeachMyAgent.environments.envs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector">ContactDetector</a></code></h4>
<ul class="">
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector.BeginContact" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector.BeginContact">BeginContact</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector.EndContact" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector.EndContact">EndContact</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector.Reset" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ContactDetector.Reset">Reset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.LidarCallback" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.LidarCallback">LidarCallback</a></code></h4>
<ul class="">
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.LidarCallback.ReportFixture" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.LidarCallback.ReportFixture">ReportFixture</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour">ParametricContinuousParkour</a></code></h4>
<ul class="">
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.clip_ceiling_values" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.clip_ceiling_values">clip_ceiling_values</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.close" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.close">close</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.color_agent_head" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.color_agent_head">color_agent_head</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.create_terrain_fixtures" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.create_terrain_fixtures">create_terrain_fixtures</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.generate_game" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.generate_game">generate_game</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.metadata" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.metadata">metadata</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.render" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.render">render</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.reset" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.reset">reset</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.seed" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.seed">seed</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.set_environment" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.set_environment">set_environment</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.set_terrain_cppn_scale" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.set_terrain_cppn_scale">set_terrain_cppn_scale</a></code></li>
<li><code><a title="TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.step" href="#TeachMyAgent.environments.envs.parametric_continuous_parkour.ParametricContinuousParkour.step">step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>